

# 一个完整的IO请求操作包括两个阶段：

-   查看数据是否就绪；
-   进行数据拷贝(将数据从内核空间拷贝到用户空间)；

## 1. 阻塞`IO`& 非阻塞`IO`

阻塞`IO`：当线程在执行过程中，发出一个`IO`请求事件。如果`IO`操作需要的条件不满足时，那么该线程就一直等待而被`OS`挂起，直到等待的条件满足为止；
非阻塞`IO`：当线程在执行过程中，发出一个`IO`请求事件。如果`IO`操作需要的条件不满足时，那么该线程就立即返回，并设置`errno`为`EAGAIN`或`EWOULDBLOCK`；

综上，阻塞`IO`与非阻塞`IO`的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

## 2. 同步`IO`&异步`IO`：消息通信机制

同步`IO`和异步`IO`模型是针对用户线程和内核的交互来说的：

同步`IO`：用户线程发出`IO`请求操作后，如果数据没有就绪，那么用户线程或内核不断地轮询数据是否就绪，即用户线程收到的是`IO`操作就绪事件。当数据就绪时，用户代码需要自行将数据从内核缓冲区拷贝到用户缓冲区。

异步`IO`：只有`IO`请求操作由用户线程发出，`IO`操作的两个阶段由内核自动完成，然后通知用户线程`IO`操作已经完成。即用户线程收到的是`IO`操作完成事件。异步`IO`需要`OS`的底层支持。

综上，同步`IO`和异步`IO`的关键区别在于数据拷贝阶段是由用户线程还是内核完成的。

## 3. 五种IO模型

-   [x] [阻塞IO]()
-   [x] [非阻塞IO]()
-   [x] [IO多路复用]()：最常用的`IO`通知机制，由`select`，`poll`，`epoll`等`IO`复用函数来实现`IO`复用机制；
-   [x] [信号驱动事件]()：注册`SIGIO`信号处理函数，当数据准备好后，由内核产生一个回调信号后，在信号处理函数中进行系统调用来完成数据的读写操作；
-   [x] 异步IO

其中前四种IO模型均为同步IO模型，第5种IO模型为异步IO模型。

## 4. 高效事件处理模式

1.  `Reactor`模式

    要求主线程(`I/O`处理单元)只负责监听文件描述符上是否有事件发生，如有事件发生，则立即通知工作线程(逻辑单元)来处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

    使用同步`IO`模型(`I/O`复用`epoll_wait`为例)实现的`Reactor`模式的工作流程如下：

    -   主线程在`epoll`内核事件表上注册感兴趣的`socket`监听的读就绪事件；
    -   主线程调用`epoll_wait`监听`socket`上是否读事件发生；
    -   当`socket`有读就绪事件发生时，`epoll_wait`通知主线程。此时，主线程将`socket`可读事件放入请求队列；
    -   睡眠在请求队列上的某个工作线程被唤醒，它从`socket`上读取数据，并处理客户请求，然后在`epoll`内核事件表上注册该`socket`上的写就绪事件。
    -   主线程调用`epoll_wait`监听`socket`上的可写事件；
    -   当`socket`可写时，`epoll_wait`通知主线程。主线程将`socket`可写事件放入请求队列；
    -   睡眠在请求队列上的某个工作线程被唤醒，它往`socket`上写入服务器处理客户请求的结果。

    

    以下是`Reactor`模式的工作流程示意图：

    ![](Reactor.png)

    

2.  `Proactor`模式

    `Proactor`模式将所有`I/O`操作都交给主线程和内核来处理，工作线程仅负责业务逻辑。使用异步`I/O`模型来实现`Proactor`模式。

    