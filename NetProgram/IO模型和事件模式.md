

# 一个完整的IO读请求操作包括两个阶段：

-   查看数据是否就绪；
-   进行数据拷贝(将数据从内核空间拷贝到用户空间)；

# 1. 阻塞IO&非阻塞IO

阻塞IO：当线程在执行过程中，发出一个IO请求事件。如果IO操作需要的条件不满足时，那么该线程就一直等待而被OS挂起，直到等待的条件满足为止；

非阻塞IO：当线程在执行过程中，发出一个IO请求事件。如果IO操作需要的条件不满足时，那么该线程就立即返回，并设置errno为EAGAIN或EWOULDBLOCK；

综上，阻塞IO与非阻塞IO的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

# 2. 同步IO&异步IO：消息通信机制

同步IO和异步IO模型是针对用户线程和内核的交互来说的：

同步IO：用户线程发出IO请求操作后，如果数据没有就绪，那么用户线程或内核不断地轮询数据是否就绪，即用户线程收到的是IO操作就绪事件。当数据就绪时，		用户代码需要自行将数据从内核缓冲区拷贝到用户缓冲区。

异步IO：只有IO请求操作由用户线程发出，IO操作的两个阶段由内核自动完成，然后通知用户线程IO操作已经完成。即用户线程收到的是IO操作完成事件。异步		IO需要OS的底层支持。

综上，同步IO和异步IO的关键区别在于数据拷贝阶段是由用户线程还是内核完成的。

# 3. 五种IO模型

-   [x] [阻塞IO]()
-   [x] [非阻塞IO]()
-   [x] [IO多路复用]()：最常用的IO通知机制，由select，poll，epoll等IO复用函数来实现IO复用机制；
-   [x] [信号驱动事件]()：注册SIGIO信号处理函数，当数据准备好后，由内核产生一个回调信号后，在信号处理函数中进行系统调用来完成数据的读写操作；
-   [x] 异步IO

其中前四种IO模型均为同步IO模型，第5种IO模型为异步IO模型。

# 4. 高效事件处理模式

1.  Reactor模式

    要求主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，如有事件发生，则立即通知工作线程(逻辑单元)来处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

    使用同步IO模型(I/O复用epoll_wait为例)实现的Reactor模式的工作流程如下：

    -   主线程在epoll内核事件表上注册感兴趣的socket监听的读就绪事件；
    -   主线程调用epoll_wait监听socket上是否读事件发生；
    -   当socket有读就绪事件发生时，epoll_wait通知主线程。此时，主线程将socket可读事件放入请求队列；
    -   睡眠在请求队列上的某个工作线程被唤醒，它从socket上读取数据，并处理客户请求，然后在epoll内核事件表上注册该socket上的写就绪事件。
    -   主线程调用epoll_wait监听socket上的可写事件；
    -   当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列；
    -   睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

    

    以下是Reactor模式的工作流程示意图：

    ![](Reactor.png)

    

2.  Proactor模式

    Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅负责业务逻辑。使用异步I/O模型来实现Proactor模式。

    