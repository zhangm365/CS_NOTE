[toc]

# 进程间的通信方式

<img src="\pics\process.png" style="zoom:80%;" />



## 1. 管道

### (1). 两个进程间可以通过管道进行通信，但由两个局限性：

-   数据只能单向传输（半双工管道）；
-   管道只能在具有公共祖先的两个进程之间使用（亲属关系）。

管道通过系统调用 **pipe** 函数创建：**pipe()** 创建一个用于进程间通信的单向数据通道。创建成功的管道是内核中的一段缓冲区，不同的进程通过内核进行通信。

```cpp
#include <unistd.h>

int pipe(int pipefd[2]);

/*
	@pipefd[0] : 指向读端，pipefd[1] : 指向写端。
	@返回值：成功返回0，失败返回-1。
*/

```

![](\pics\pipe.png)



单个进程中的管道几乎没有任何用处。通常，进程先调用 **pipe** 创建管道，然后调用 **fork**，从而创建从父进程到子进程的 **IPC** 通道。如下图所示：

![](\pics\pipe_fork.png)



当 **fork** 后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭读端 ( fd[0] )，子进程关闭写端 ( fd[1] )。如下图所示：

![](\pics\pipe_fork1.png)

### (2).  无名管道代码

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main( int argc, char *argv[] )
{
    
    int fd[2];
    pid_t pid;
    
    char buf;
    
   	if( argc != 2 )
    {
        fprintf(stderr, "Usage: %s <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    if( pipe(fd) == -1 )
    {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    
    pid = fork();
    
    if( pid == -1 )
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    
    if( pid == 0 )	/* Child read from pipe */
    {
        close(fd[1]);	// close write end
        while( read(fd[0], &buf, 1) > 0 )
        {
            write( STDOUT_FILENO, &buf, 1 );
        }
        
        write( STDOUT_FILENO, "\n", 1 );
        close(fd[0]);
        _exit(EXIT_SUCCESS);
        
    }
    else	// parent write argv[1] to pipe
    {
        close(fd[0]);
        write( fd[1], argv[1], strlen(argv[1]) );
        close(fd[1]);	// 
        wait(NULL);		// write for child
        exit(EXIT_SUCCESS);
    }
    return 0;
    
}
```

### (3). 命名管道 ：FIFO

无名管道只能在两个相关的进程间使用，且这两个相关的进程还要有一个共同创建了它们的祖先进程。然而，通过 FIFO ，不相关的进程也可以进行通信。

FIFO 是一种文件类型。操作命名管道类似于普通文件的读写操作。

```c
NAME
	mkfifo - make a FIFO special file( a named pipe )

SYNOPSIS
    #include <sys/types.h>
    #include <sys/stat.h>
    int mkfifo( const char *pathname, mode_t mode );
/*
	@返回值: 成功返回0，失败返回-1并设置errno
*/
```



## 2. 消息队列

## 3. 共享内存

## 4. 信号量

## 5. socket 通信