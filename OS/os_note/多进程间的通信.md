[toc]

# 进程间的通信方式

<img src="\pics\process.png" style="zoom:80%;" />



## 1. 管道

两个进程间可以通过管道进行通信，但由两个局限性：

-   数据只能单向传输（半双工管道）；
-   管道只能在具有公共祖先的两个进程之间使用（亲属关系）。

其中有名管道 FIFO 不存在第二个缺陷。

### (1) . 管道操作函数：pipe，fork 

管道通过系统调用 **pipe** 函数创建：**pipe()** 创建一个用于进程间通信的单向数据通道。创建成功的管道是内核中的一段缓冲区，不同的进程通过内核进行通信。

```cpp
#include <unistd.h>

int pipe(int pipefd[2]);

/*
	@pipefd[0] : 指向读端，pipefd[1] : 指向写端。
	@返回值：成功返回0，失败返回-1。
*/

```

![](\pics\pipe.png)



单个进程中的管道几乎没有任何用处。通常，进程先调用 **pipe** 创建管道，然后调用 **fork**，父子进程分别引用计数于管道。从而可以创建从父进程到子进程的 **IPC** 通道。如下图所示：

![](\pics\pipe_fork.png)



当 **fork** 后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭读端 ( fd[0] )，子进程关闭写端 ( fd[1] )。如下图所示：

![](\pics\pipe_fork1.png)

### (2).  管道代码

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main( int argc, char *argv[] )
{
    
    int fd[2];
    pid_t pid;
    
    char buf;
    
   	if( argc != 2 )
    {
        fprintf(stderr, "Usage: %s <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    if( pipe(fd) == -1 )
    {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    
    pid = fork();
    
    if( pid == -1 )
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    
    if( pid == 0 )	/* Child read from pipe */
    {
        close(fd[1]);	// close write end
        while( read(fd[0], &buf, 1) > 0 )
        {
            write( STDOUT_FILENO, &buf, 1 );
        }
        
        write( STDOUT_FILENO, "\n", 1 );
        close(fd[0]);
        _exit(EXIT_SUCCESS);
        
    }
    else	// pid > 0: parent write argv[1] to pipe
    {
        close(fd[0]);
        write( fd[1], argv[1], strlen(argv[1]) );
        close(fd[1]);	// 
        wait(NULL);		// write for child
        exit(EXIT_SUCCESS);
    }
    return 0;
    
}
```

### (3). 命名管道 ：FIFO

无名管道只能在两个相关的进程间使用，且这两个相关的进程还要有一个共同创建了它们的祖先进程。然而，通过 FIFO ，不相关的进程也可以进行通信，并且可以用于多个进程间的通信。

FIFO 是一种文件类型。操作命名管道类似于普通文件的读写操作。通过系统函数 **mkfifo()** 来创建有名管道文件。

```c
NAME
	mkfifo, mkfifoat - make a FIFO special file( a named pipe )

SYNOPSIS
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int mkfifo( const char *pathname, mode_t mode );
	
    int mkfifoat(int dirfd, const char *pathname, mode_t mode);

/*
	@返回值: 成功返回0，失败返回-1并设置errno
*/
```

code ： fifo_write.c 和 fifo_read.c

综上，管道的通信方式较低效，不适合进程间频繁的数据交流。

## 2. 消息队列

**XSI** 接口是 **POSIX** 标准定义的一组可选系统接口。

XSI IPC 函数是紧密基于 System V 的 IPC 函数的。有 3 种 **XSI** 的 **IPC** 函数：消息队列、信号量、共享内存。可以使用命令 ipcs 和 ipcrm 来管理 IPC 对象。

### (1).  消息队列是存在于内核中的消息链接表

消息队列在内核中用一个非负整数的标识符来引用，因此，在一个消息队列中传递信息时，只需要知道其队列标识符即可。标识符只是 **IPC** 对象的内部名，为使多个合作进程可以在同一 **IPC** 对象上汇聚，需要提供一个外部命名方案。因此，每个 **IPC** 对象都与一个键相关联，将这个键作为该对象的外部名。消息队列通过调用 **msgget** 来创建对应的 **IPC** 结构，但需要给 **msgget** 指定一个键，这个键由内核变成对应的 IPC 结构标识符。  

每个消息是一个独立的数据块，包括：一个正的长整型类型的字段、一个非负的长度以及实际的数据字节数。

每个队列都有一个 msqid_ds 结构与其关联：

```c
The msqid_ds data structure is defined in <sys/msg.h> as follows:

struct msqid_ds {
    struct ipc_perm msg_perm;     /* Ownership and permissions */
    time_t          msg_stime;    /* Time of last msgsnd(2) */
    time_t          msg_rtime;    /* Time of last msgrcv(2) */
    time_t          msg_ctime;    /* Time of last change */
    unsigned long   __msg_cbytes; /* Current number of bytes in
                                                queue (nonstandard) */
    msgqnum_t       msg_qnum;     /* Current number of messages
                                                in queue */
    msglen_t        msg_qbytes;   /* Maximum number of bytes
                                                allowed in queue */
    pid_t           msg_lspid;    /* PID of last msgsnd(2) */
    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
};

The ipc_perm structure is defined as follows (the highlighted fields are settable using IPC_SET):

struct ipc_perm {
    key_t          __key;       /* Key supplied to msgget(2) */
    uid_t          uid;         /* Effective UID of owner */
    gid_t          gid;         /* Effective GID of owner */
    uid_t          cuid;        /* Effective UID of creator */
    gid_t          cgid;        /* Effective GID of creator */
    unsigned short mode;        /* Permissions */
    unsigned short __seq;       /* Sequence number */
};

```



### (2) . 创建队列：ftok，msgget

**msgget** ：创建一个新队列或打开一个现有队列。

**ftok** 函数提供唯一的服务就是把一个路径名和项目 ID 产生一个键。首先通过调用 **ftok** 产生一个 key 。 该函数原型如下：

```c
#include <sys/ipc.h>
key_t ftok( const char *path, int id );

/*
	@path ：必须存在的路径名
	@id : 用户自定义
	@返回值：
        成功返回：一个由内核生成的key, 是定义在 sys/types.h 中的一个长整型
        失败返回：-1。
*/
```

**msgget** 函数原型如下：

```c
NAME
       msgget - get a System V message queue identifier

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgget(key_t key, int msgflg);

/*
	@ desc ：
		当 key 值不是 IPC_PRIVATE 且 msgflg 是 0 时，表示引用一个现有的消息队列；
		当 key 值不是 IPC_PRIVATE 且 给定的 key 没有关联到已有的消息队列时，msgflg 指定为IPC_CREAT, 则创建一个消息队列。
	
	@ key : 由 ftok 函数生成的外部名 key，而不是使用 IPC_PRIVATE。当 key 使用 IPC_PRIVATE，总是创建一个新的消息队列。
	
	@ msgflg : 标记位设置。ipc_perm 结构中的 mode 由 msgflg 来设置初始化。
		想要创建一个新队列时，要指定 IPC_CREAT。
		当使用 IPC_CREAT | IPC_EXCL 时, 若给定的 key 已有关联的消息队列，则返回失败并设置 errno 为 EEXIST。
		若没有指定 IPC_EXCL，当 key 已关联消息队列，则会引用现有的消息队列。
	Usage: IPC_CREAT | 权限位，如 IPC_CREAT | 0666。
	
	@ 返回值：
		成功返回：队列标识符ID（一个非负整数）
    	失败返回：-1.
	
		当函数成功返回时，会初始化控制消息队列的结构体 msqid_ds 中的相关数据。
		• msg_perm.cuid and msg_perm.uid are set to the effective user ID of the calling process.
		• msg_perm.cgid and msg_perm.gid are set to the effective group ID of the calling process.

		• The least significant 9 bits of msg_perm.mode are set to the least significant 9 bits of msgflg.

		• msg_qnum, msg_lspid, msg_lrpid, msg_stime, and msg_rtime are set to 0.

		• msg_ctime is set to the current time.

		• msg_qbytes is set to the system limit MSGMNB.
*/

```



所以，先调用 **ftok** 函数 生成一个键 **key**，然后传给 **msgget** 函数来创建或引用一个消息队列。



### (3) . 发送和接收消息：msgsnd，msgrcv

发送消息和接受消息的函数如下：

```c
NAME
       msgrcv, msgsnd - System V message queue operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
		
/*
	@desc：
		每次追加一个由 msgp 指定消息体到队列 msgid 的尾部。
	
	@ msqid: msgget函数的返回队列ID
	@ msgp: 指向要发送的消息体，它定义的通用结构如下：
	
	struct msgbuf {
		long mtype;        // message type, must be > 0 
		char mtext[1];     // message data, 自定义大小 
    };
	mtype：必须为正整数，在接收端可以被用来指定要接收哪个数据包
	mtext是一个字符数组，保存用户想要发送的数据，数组的大小由msgsz指定。当没有 mtext 数据域时，表示消息长度为0。
    
    @ msgsz : 指定mtext字符数组的大小，可以为0。
    @ msgflg: 标记位。
    	当消息队列没有可用空间时，默认阻塞直到空间可用。
        IPC_NOWAIT ： 若消息队列已满，立即失败返回设置 errno 为 EAGAIN 。
    @ return value
    	成功: 0
    	失败: -1, 
        
*/
       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);
/*
	从给定的消息队列中移除消息，并且放在 msgp 中。
	@ msqid : 消息队列ID 
	@ msgp : 指向存放消息体的缓冲区
	@ msgsz : msgp 结构中成员 mtext 的大小
	@ msgtyp ：
		== 0 : 消息队列中的第一个消息被读取;
		> 0 : 则读取消息队列中等于 mtype 的第一个消息体; 这样就可以实现非先进先出次序读取消息。
		< 0 : 取 msgtyp 的绝对值，然后读取 小于等于 其绝对值的最小类型的消息体。
	@ msgflg : 
		IPC_NOWAIT: 当队列为空时，则立即失败返回设置 errno 为 ENOMSG。否则，一直阻塞到队列中有消息可读。
		MSG_NOERROR: 当 mtext 的大小 大于 msgsz，则截断读取消息。若没有指定 MSG_NOERROR, 则会因为消息太长导致读取消息失败（消息不会从队列中移除），返回-1并设置			errno 为 E2BIG.
	@返回值：
        失败：返回-1
        成功：返回实际复制到mtext数组中的字节数
	
*/

```



### (4) . 消息队列控制：msgctl 

对队列执行多种操作。

```c
NAME         
       msgctl - System V message control operations
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/msg.h>
       int msgctl(int msqid, int cmd, struct msqid_ds *buf);

/*
	@ msgid : 消息队列ID
	@ cmd
		IPC_STAT: 读取队列 msqid_ds 结构，并把它放入由 buf 指定的结构中。 
		IPC_SET:  将 buf 指向的结构中的一些数据写入内核中的 msqid_ds 结构中。更新的数据为
			msg_qbytes, msg_perm.uid, msg_perm.gid, and (the leastsignificant 9 bits of) msg_perm.mode。
			
		IPC_RMID: 从系统中删除消息队列以及仍在该队列中的所有数据。这种删除立即生效
*/

```

### (5) . 代码示例

msg_snd.c 和 msg_rcv.c 

## 3. 共享内存

## 4. 信号量

### (1) . 信号量是一个计数器，用于为多进程提供对共享数据对象的访问

为了获得共享资源，进程需要执行以下操作：

1.  测试控制该资源的信号量；
2.  若此信号量为正，则进程可以使用该资源。在这样情况下，进程会将信号量减 1，表示它使用了一个资源单位；---> P 操作
3.  若此信号量为 0，则进程进入休眠状态，直至信号量值大于 0。当进程被唤醒后，转入步骤 1。
4.  当进程不在使用由一个信号量控制的共享资源时，该信号量增 1。如果有进程正在休眠等待此信号量，则唤醒他们。---> V 操作

为了正确地实现信号量，信号量值的增 1 操作及减 1 操作应当是原子操作。因此，信号量通常在内核中实现。

常用的信号量形式被称为二元信号量。它控制单个资源，其初始值为 1 。我们把访问某种共享资源的代码块称为 "临界区" 。

### (2) . XSI 信号量

XSI 信号量实现较复杂。原因如下：

-   信号量并非单个非负值，而是必须定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量。
-   信号量的创建 ( semget ) 是独立于它的初始化的 ( semctl ) 。这是一个致命的缺点，因为不能原子地创建一个信号量集合，并对该集合中的各个信号量值赋初值。
-   即使进程没有使用各种形式的 XSI IPC，它们仍然是存在的。

内核为每个信号量集合维护一个 semid_ds 数据结构，如下：

```c
The semid_ds data structure is defined in <sys/sem.h> as follows:

           struct semid_ds {
               struct ipc_perm sem_perm;  /* Ownership and permissions */
               time_t          sem_otime; /* Last semop time */
               time_t          sem_ctime; /* Creation time/time of last
                                             modification via semctl() */
               unsigned long   sem_nsems; /* No. of semaphores in set */
           };

       The fields of the semid_ds structure are as follows:

       sem_perm
              This is an ipc_perm structure (see below) that specifies
              the access permissions on the semaphore set.

       sem_otime
              Time of last semop(2) system call.

       sem_ctime
              Time of creation of semaphore set or time of last semctl()
              IPCSET, SETVAL, or SETALL operation.

       sem_nsems
              Number of semaphores in the set.  Each semaphore of the
              set is referenced by a nonnegative integer ranging from 0
              to sem_nsems-1.
           
The ipc_perm structure is defined as follows (the highlighted fields are settable using IPC_SET):

    struct ipc_perm {
        key_t          __key; /* Key supplied to semget(2) */
        uid_t          uid;   /* Effective UID of owner */
        gid_t          gid;   /* Effective GID of owner */
        uid_t          cuid;  /* Effective UID of creator */
        gid_t          cgid;  /* Effective GID of creator */
        unsigned short mode;  /* Permissions */
        unsigned short __seq; /* Sequence number */
    };
```



### (3) . 创建信号量集合  **semget**  

```c
NAME         
       semget - get a System V semaphore set identifier
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semget(key_t key, int nsems, int semflg);

/*
	@ desc
		创建一个新信号量集合或引用一个现有集合。
	@ key : ftok 函数生成的键 key
	@ nsems ：创建的信号量集合中信号量的个数，此时 nsems 必须大于 0。如果为 0，则表示引用一个现有集合。
	@ semflg: IPC_CREAT 指定创建一个新信号量集合。
	@ return value:
		成功 ： 信号量集合ID;
		失败 ： -1
	@ other
		When creating a new semaphore set, semget() initializes the set's
       associated data structure, semid_ds (see semctl(2)), as follows:

       • sem_perm.cuid and sem_perm.uid are set to the effective user ID
         of the calling process.

       • sem_perm.cgid and sem_perm.gid are set to the effective group
         ID of the calling process.

       • The least significant 9 bits of sem_perm.mode are set to the
         least significant 9 bits of semflg.

       • sem_nsems is set to the value of nsems.

       • sem_otime is set to 0.

       • sem_ctime is set to the current time.
*/
```

### (4) .  信号量操作函数  semctl，semop 

**semctl** 对集合上的多个信号量进行控制，即对集合中的信号量进行初始化。

```c
NAME        
    semctl - System V semaphore control operations  
SYNOPSIS        
    #include <sys/types.h>        
    #include <sys/ipc.h>        
    #include <sys/sem.h>         
    int semctl(int semid, int semnum, int cmd, ...); 

/*
	@ desc
		对信号量集合中的全部信号量或者编号为 semnum 的特定信号量进行操作，具体操作由 cmd 命令指定。集合中的信号量从 0 开始编号。
		这个函数根据 cmd 命令有 3 个或 4 个参数，第 4 个参数的结构如下：
		 union semun {                
		 	int              val;    // Value for SETVAL              
			struct semid_ds *buf;    // Buffer for IPC_STAT, IPC_SET              
			unsigned short  *array;  // Array for GETALL, SETALL               
			struct seminfo  *__buf;  // Buffer for IPC_INFO (Linux-specific)       
		};
		
	@ semid ： 集合标识符
	@ semnum : 指定集合中的一个成员，semnum 的值位于 [0, nsems-1] 区间内
	@ cmd 
		IPC_STAT : 复制内核中的集合的属性到 arg.buf 中;
		IPC_SET ：将 arg.buf 中的一些属性写入到 内核中的集合属性;
		IPC_RMID ：从系统中立即删除信号量集合，参数化 semnum 将被忽略;
		GETVAL ：返回成员 semnum 的 semval 值;
		SETVAL ：设置成员 semnum 的 semval 值，该值由 arg.val 指定
	
	@ return value
		失败：-1
		成功：所有GET命令除GETALL外，semctl 函数返回对应的值。其他命令返回 0。

*/

```

**semop** 执行信号量集合上的操作数组。

**semop** 函数具有原子性。它要么全部执行操作数组中的所有操作，要么一个也不做。

```c
NAME         
       semop, semtimedop - System V semaphore operations
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semop(int semid, struct sembuf *sops, size_t nsops);
       int semtimedop(int semid, struct sembuf *sops, size_t nsops,
                      const struct timespec *timeout);

   Feature Test Macro Requirements for glibc (see
   feature_test_macros(7)):

       semtimedop():
           _GNU_SOURCE
               
Each semaphore in a System V semaphore set has the following associated values:             
    unsigned short  semval;   /* semaphore value */            
    unsigned short  semzcnt;  /* # waiting for zero */            
    unsigned short  semncnt;  /* # waiting for increase */           
    pid_t           sempid;   /* PID of process that last 
    
/*
	@ desc
		由 sops 指定的数组中的每个元素表明对一个信号量的具体操作，sops 数组大小为 nsops。数组中的每个元素是如下的结构：
		struct sembuf
		{
			unsigned short sem_num;  // semaphore number 
			short sem_op;   // semaphore operation 
			short sem_flg;  // operation flags 

		}
		@ sem_num : 指定的要操作的信号量编号
		@ sem_op : 对信号量的具体操作
			> 0 : 进程释放占用的资源。操作会增加 semval 的值; 如果操作中 SEM_UNDO 被指定，则系统将从该信号量调整值中减去值 sem_op。
			== 0 ：调用进程希望等待到该信号量值变成 0, 如果为 0, 那么函数立即返回，进程继续执行。否则默认是阻塞的; 如果指定了 IPC_NOWAIT, 则不阻塞立					即失败返回。 
			< 0 : 要获取由该信号量控制的资源。
				如果 semval 大于等于 sem_op 的绝对值，操作立即执行，并从信号量中减去 sem_op 的绝对值。如果指定了 SEM_UNDO, 系统将 sem_op 的绝对值				  加到该信号量调整值上。如果 sem_op 的绝对值大于 semval 的值，若指定了 IPC_NOWAIT, 则进程不阻塞立即返回并设置 errno 为 EAGAIN。否					则，该进程一直阻塞直到以下条件中的任一个发生：
				1. 资源可用;
				2. 信号量集合从系统中被移除，设置 errno 为 EIDRM;
				3. 调用进程捕捉到一个信号，
		@ sem_flg : 标记位
			IPC_NOWAIT : 进程不阻塞等待所申请的资源;
			SEM_UNDO : 如果进程意外终止，则归还进程持有的信号量资源。
	
	@ semid : 集合ID
	@ sops : 操作数组
		用来指定对集合中的信号量要执行的操作。按数组顺序执行的一组原子操作。
	@ nsops : 操作数组的大小
	@ return value
		成功 ：0
		失败 ：-1。
*/
```

代码展示：

sem文件夹



## 5. socket 通信

