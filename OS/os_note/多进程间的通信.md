[toc]

# 进程间的通信方式

<img src="\pics\process.png" style="zoom:80%;" />



## 1. 管道

两个进程间可以通过管道进行通信，但由两个局限性：

-   数据只能单向传输（半双工管道）；
-   管道只能在具有公共祖先的两个进程之间使用（亲属关系）。

其中有名管道 FIFO 不存在第二个缺陷。

### (1) . 管道操作函数：pipe，fork 

管道通过系统调用 **pipe** 函数创建：**pipe()** 创建一个用于进程间通信的单向数据通道。创建成功的管道是内核中的一段缓冲区，不同的进程通过内核进行通信。

```cpp
#include <unistd.h>

int pipe(int pipefd[2]);

/*
	@pipefd[0] : 指向读端，pipefd[1] : 指向写端。
	@返回值：成功返回0，失败返回-1。
*/

```

![](\pics\pipe.png)



单个进程中的管道几乎没有任何用处。通常，进程先调用 **pipe** 创建管道，然后调用 **fork**，父子进程分别引用计数于管道。从而可以创建从父进程到子进程的 **IPC** 通道。如下图所示：

![](\pics\pipe_fork.png)



当 **fork** 后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭读端 ( fd[0] )，子进程关闭写端 ( fd[1] )。如下图所示：

![](\pics\pipe_fork1.png)

### (2).  管道代码

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main( int argc, char *argv[] )
{
    
    int fd[2];
    pid_t pid;
    
    char buf;
    
   	if( argc != 2 )
    {
        fprintf(stderr, "Usage: %s <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    if( pipe(fd) == -1 )
    {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    
    pid = fork();
    
    if( pid == -1 )
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    
    if( pid == 0 )	/* Child read from pipe */
    {
        close(fd[1]);	// close write end
        while( read(fd[0], &buf, 1) > 0 )
        {
            write( STDOUT_FILENO, &buf, 1 );
        }
        
        write( STDOUT_FILENO, "\n", 1 );
        close(fd[0]);
        _exit(EXIT_SUCCESS);
        
    }
    else	// pid > 0: parent write argv[1] to pipe
    {
        close(fd[0]);
        write( fd[1], argv[1], strlen(argv[1]) );
        close(fd[1]);	// 
        wait(NULL);		// write for child
        exit(EXIT_SUCCESS);
    }
    return 0;
    
}
```

### (3). 命名管道 ：FIFO

无名管道只能在两个相关的进程间使用，且这两个相关的进程还要有一个共同创建了它们的祖先进程。然而，通过 FIFO ，不相关的进程也可以进行通信，并且可以用于多个进程间的通信。

FIFO 是一种文件类型。操作命名管道类似于普通文件的读写操作。通过系统函数 **mkfifo()** 来创建有名管道文件。

```c
NAME
	mkfifo, mkfifoat - make a FIFO special file( a named pipe )

SYNOPSIS
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int mkfifo( const char *pathname, mode_t mode );
	
    int mkfifoat(int dirfd, const char *pathname, mode_t mode);

/*
	@返回值: 成功返回0，失败返回-1并设置errno
*/
```

code ： fifo_write.c 和 fifo_read.c

综上，管道的通信方式较低效，不适合进程间频繁的数据交流。

## 2. 消息队列

有 3 种 System V 的 **IPC** 函数：消息队列、信号量、共享内存。可以使用命令 ipcs 和 ipcrm 来管理 IPC 对象。

### (1).  消息队列是存在于内核中的消息链接表

消息队列在内核中用一个非负整数的标识符来引用，因此，在一个消息队列中传递信息时，只需要知道其队列标识符即可。标识符只是 **IPC** 对象的内部名，为使多个合作进程可以在同一 **IPC** 对象上汇聚，需要提供一个外部命名方案。因此，每个 **IPC** 对象都与一个键相关联，将这个键作为该对象的外部名。消息队列通过调用 **msgget** 来创建对应的 **IPC** 结构，但需要给 **msgget** 指定一个键，这个键由内核变成对应的 IPC 结构标识符。  

每个消息是一个独立的数据块，包括：一个正的长整型类型的字段、一个非负的长度以及实际的数据字节数。

每个队列都有一个 msqid_ds 结构与其关联：

```c
The msqid_ds data structure is defined in <sys/msg.h> as follows:

struct msqid_ds {
    struct ipc_perm msg_perm;     /* Ownership and permissions */
    time_t          msg_stime;    /* Time of last msgsnd(2) */
    time_t          msg_rtime;    /* Time of last msgrcv(2) */
    time_t          msg_ctime;    /* Time of last change */
    unsigned long   __msg_cbytes; /* Current number of bytes in
                                                queue (nonstandard) */
    msgqnum_t       msg_qnum;     /* Current number of messages
                                                in queue */
    msglen_t        msg_qbytes;   /* Maximum number of bytes
                                                allowed in queue */
    pid_t           msg_lspid;    /* PID of last msgsnd(2) */
    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
};

The ipc_perm structure is defined as follows (the highlighted fields are settable using IPC_SET):

struct ipc_perm {
    key_t          __key;       /* Key supplied to msgget(2) */
    uid_t          uid;         /* Effective UID of owner */
    gid_t          gid;         /* Effective GID of owner */
    uid_t          cuid;        /* Effective UID of creator */
    gid_t          cgid;        /* Effective GID of creator */
    unsigned short mode;        /* Permissions */
    unsigned short __seq;       /* Sequence number */
};

```



### (2) . 创建队列：ftok，msgget

**msgget** ：创建一个新队列或打开一个现有队列。

**ftok** 函数提供唯一的服务就是把一个路径名和项目 ID 产生一个键。首先通过调用 **ftok** 产生一个 key 。 该函数原型如下：

```c
#include <sys/ipc.h>
key_t ftok( const char *path, int id );

/*
	@path ：必须存在的路径名
	@id : 用户自定义
	@返回值：
        成功返回：一个由内核生成的key, 是定义在 sys/types.h 中的一个长整型
        失败返回：-1。
*/
```

**msgget** 函数原型如下：

```c
NAME
       msgget - get a System V message queue identifier

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgget(key_t key, int msgflg);

/*
	@ desc ：
		当 key 值不是 IPC_PRIVATE 且 msgflg 是 0 时，表示引用一个现有的消息队列；
		当 key 值不是 IPC_PRIVATE 且 给定的 key 没有关联到已有的消息队列时，msgflg 指定为IPC_CREAT, 则创建一个消息队列。
	
	@ key : 由 ftok 函数生成的外部名 key，而不是使用 IPC_PRIVATE。当 key 使用 IPC_PRIVATE，总是创建一个新的消息队列。
	
	@ msgflg : 标记位设置。ipc_perm 结构中的 mode 由 msgflg 来设置初始化。
		想要创建一个新队列时，要指定 IPC_CREAT。
		当使用 IPC_CREAT | IPC_EXCL 时, 若给定的 key 已有关联的消息队列，则返回失败并设置 errno 为 EEXIST。
		若没有指定 IPC_EXCL，当 key 已关联消息队列，则会引用现有的消息队列。
	Usage: IPC_CREAT | 权限位，如 IPC_CREAT | 0666。
	
	@ 返回值：
		成功返回：队列标识符ID（一个非负整数）
    	失败返回：-1.
	
		当函数成功返回时，会初始化控制消息队列的结构体 msqid_ds 中的相关数据。
		• msg_perm.cuid and msg_perm.uid are set to the effective user ID of the calling process.
		• msg_perm.cgid and msg_perm.gid are set to the effective group ID of the calling process.

		• The least significant 9 bits of msg_perm.mode are set to the least significant 9 bits of msgflg.

		• msg_qnum, msg_lspid, msg_lrpid, msg_stime, and msg_rtime are set to 0.

		• msg_ctime is set to the current time.

		• msg_qbytes is set to the system limit MSGMNB.
*/

```



所以，先调用 **ftok** 函数 生成一个键 **key**，然后传给 **msgget** 函数来创建或引用一个消息队列。



### (3) . 发送和接收消息：msgsnd，msgrcv

发送消息和接受消息的函数如下：

```c
NAME
       msgrcv, msgsnd - System V message queue operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
		
/*
	@desc：
		每次追加一个由 msgp 指定消息体到队列 msgid 的尾部。
	
	@ msqid: msgget函数的返回队列ID
	@ msgp: 指向要发送的消息体，它定义的通用结构如下：
	
	struct msgbuf {
		long mtype;        // message type, must be > 0 
		char mtext[1];     // message data, 自定义大小 
    };
	mtype：必须为正整数，在接收端可以被用来指定要接收哪个数据包
	mtext是一个字符数组，保存用户想要发送的数据，数组的大小由msgsz指定。当没有 mtext 数据域时，表示消息长度为0。
    
    @ msgsz : 指定mtext字符数组的大小，可以为0。
    @ msgflg: 标记位。
    	当消息队列没有可用空间时，默认阻塞直到空间可用。
        IPC_NOWAIT ： 若消息队列已满，立即失败返回设置 errno 为 EAGAIN 。
    @ return value
    	成功: 0
    	失败: -1, 
        
*/
       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);
/*
	从给定的消息队列中移除消息，并且放在 msgp 中。
	@ msqid : 消息队列ID 
	@ msgp : 指向存放消息体的缓冲区
	@ msgsz : msgp 结构中成员 mtext 的大小
	@ msgtyp ：
		== 0 : 消息队列中的第一个消息被读取;
		> 0 : 则读取消息队列中等于 mtype 的第一个消息体; 这样就可以实现非先进先出次序读取消息。
		< 0 : 取 msgtyp 的绝对值，然后读取 小于等于 其绝对值的最小类型的消息体。
	@ msgflg : 
		IPC_NOWAIT: 当队列为空时，则立即失败返回设置 errno 为 ENOMSG。否则，一直阻塞到队列中有消息可读。
		MSG_NOERROR: 当 mtext 的大小 大于 msgsz，则截断读取消息。若没有指定 MSG_NOERROR, 则会因为消息太长导致读取消息失败（消息不会从队列中移除），返回-1并设置			errno 为 E2BIG.
	@返回值：
        失败：返回-1
        成功：返回实际复制到mtext数组中的字节数
	
*/

```



### (4) . 消息队列控制：msgctl 

对队列执行多种操作。

```c
NAME         
       msgctl - System V message control operations
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/msg.h>
       int msgctl(int msqid, int cmd, struct msqid_ds *buf);

/*
	@ msgid : 消息队列ID
	@ cmd
		IPC_STAT: 读取队列 msqid_ds 结构，并把它放入由 buf 指定的结构中。 
		IPC_SET:  将 buf 指向的结构中的一些数据写入内核中的 msqid_ds 结构中。更新的数据为
			msg_qbytes, msg_perm.uid, msg_perm.gid, and (the leastsignificant 9 bits of) msg_perm.mode。
			
		IPC_RMID: 从系统中删除消息队列以及仍在该队列中的所有数据。这种删除立即生效
*/

```

### (5) . 代码示例

msg_snd.c 和 msg_rcv.c 

## 3. 共享内存

## 4. 信号量

## 5. socket 通信