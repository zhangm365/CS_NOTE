# 一. 死锁

## 1. 如果一组进程中的每一个进程都在等待仅由该进程组中的其他进程才能引发的事件，那么该进程组就是死锁的。

# 二. 死锁产生的四个必要条件

## 1. 互斥：线程对于需要的资源进行互斥的访问；

## 2. 持有并等待：线程拥有了资源(例如已持有的锁)，同时又在申请其他资源(例如: 需要获得的锁)；

## 3. 不可剥夺性：线程已获得的资源，不可被抢占；

## 4. 循环等待：线程之间在申请资源上存在环路；

# 三. 如何预防死锁

## 1. 破坏循环等待条件

使用**全序**或**偏序**的方法来安排锁的获取并避免死锁。全序和偏序都需要细致的锁策略的设计和实现。

全序：例如系统共有两个锁L1和L2，那么我们每次先申请L1，再申请L2，就可以避免死锁。这样严格的顺序避免了死锁的循环等待，故不会产生死锁。

那么在更复杂的系统中不会只有两个锁，锁的全序可能很难做到。此时，才有偏序的方法安排锁的获取并避免死锁的产生。

偏序：linux的内存映射代码就是一个偏序锁例子。

代码开头注释表明了10组不同的加锁顺序，包括简单的关系，比如i_mutex早于i_mmap_mutex，也包括复杂的关系，比如i_mmap_mutex早于private_lock，早于swap_lock，早于mapping->tree_lock。

## 2. 破坏持有并等待条件

-   方法1：在一个进程运行之前，一次性申请在其整个运行期间所需的全部资源，这样此进程就不会在运行期间再申请其他资源，破坏了"请求"的条件；在系统分配资源时，只要有一种资源不满足该进程的需要，那就让该进程等待，这样就破坏了"保持"条件；
-   方法2：每个进程在申请新的资源前，先释放其所占资源。然后在依次申请所需资源。

## 3. 破坏不可抢占条件

​	允许对所占用的资源被剥夺

## 4.完全避免互斥

代码通常都存在临界区，因此很难避免互斥。

无等待(wait-free)的数据结构想法：通过强大的硬件指令，构造出不需要锁的数据结构。

一个简单的例子，假设我们有比较并交换（compare-and-swap）指令，是一种由硬件提供的原子指令，做下面的事：

```cpp
int CompareAndSwap(int *address, int expected, int new) 
{
    if (*address == expected) 
    {
        *address = new;
        return 1; // success      
    }
    return 0;   // failure   
}

//假如我们原子地想给某个值增加特定的数量, 则可以有以下实现
void AtomicIncrement(int *value, int amount) 
{
    do 
    {
        int old = *value;
        
    } while (CompareAndSwap(value, old, old + amount) == 0);
    
}
```



# 四. 银行家算法避免死锁

## 1. 银行家算法：在分配资源之前，查看分配资源后是否会导致系统死锁，如果会发生，则不进行分配资源，否则就分配。





