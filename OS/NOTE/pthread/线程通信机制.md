# 线程同步机制

当多个线程共享相同的内存时，需要确保每个线程看到一致的数据视图。所以，当多个线程试图在同一时间修改同一变量时，需要进行同步。

## 1. `POSIX`信号量

`POSIX` 信号量有两种形式：命名的和未命名的，它们的差异仅仅是创建和销毁的形式上。

### 1.1 未命名的信号量

未命名的信号量由 `sem_init` 函数创建，由 `sem_destroy` 函数销毁。它只能应用于同一进程中的线程或不同进程中已经映射相同内存内容到它们的地址空间中的线程。

```c
NAME
	sem_init - initialize an unnamed semaphore
SYNOPSIS
	#include <semaphore.h>
	int sem_init(sem_t *sem, int pshared, unsigned int value);
	
	sem_destroy - destroy an unnamed semaphore
	int sem_destroy(sem_t *sem);

	Link with -pthread.

@ decs ：
	
	初始化一个由 sem 指定的无名信号量，参数 value 是信号的初始值。
	
	sem_init() initializes the unnamed semaphore at the address pointed to by 'sem'.  The 'value' argument specifies the initial 			value for the semaphore.

@ pshared :
	The 'pshared' argument indicates whether this semaphore is to be shared between the threads of a process, or between processes.
	If  pshared  has  the value 0, then the semaphore is shared between the threads of a process, and should be located at some 			address that is visible to all threads (e.g., a global variable, or a variable allocated dynamically on the heap).
	
	If pshared is nonzero, then the semaphore is shared between processes, and should be located in a region of  shared  memory  (see 		shm_open(3),  mmap(2),  and  shmget(2)).
	(Since a child created by fork(2) inherits its parent's memory mappings, it can also access the semaphore.)  Any process that can 		access the shared memory region can operate on the semaphore using sem_post(3), sem_wait(3), and so on. 
@ value :
     信号量的初始值
	
@ 返回值 ：
	成功返回 0， 失败返回 -1
	
-------------------------------------
sem_destroy 函数
@ desc ：
	销毁未命名的信号量。使用一个已经销毁的未命名信号量将产生未定义的结果。
	
	sem_destroy() destroys the unnamed semaphore at the address pointed to by 'sem'.
	Only a semaphore that has been initialized by 'sem_init(3)' should be destroyed using 'sem_destroy()'.
@ 返回值 ：
	成功返回 0, 失败返回 -1。

```

### 1.2 命名信号量

命令信号量由 `sem_open` 函数创建或引用现有的信号量，它可以通过名字访问，因此它可以在任何已知它名字的进程中的线程使用。
`sem_close` 函数用来关闭一个命令信号量，而 `sem_unlink` 函数则移除一个命名信号量。

```c
NAME
	sem_open - initialize and open a named semaphore
    
	sem_close - close a named semaphore

	sem_unlink - remove a named semaphore
    
SYNOPSIS
	#include <fcntl.h>           /* For O_* constants */
	#include <sys/stat.h>        /* For mode constants */
	#include <semaphore.h>
	
	sem_t *sem_open(const char *name, int oflag);
	sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
	
	int sem_close(sem_t *sem);
	int sem_unlink(const char *name);

/*------------------------
@ desc :
	sem_open() creates a new POSIX semaphore or opens an existing semaphore. The semaphore is identified by 'name'. For details of the 		construction of 'name', see sem_overview(7).
        
@ oflag :
	指定控制调用操作的标志。
	0 ： 表示打开现有的命名信号量，则仅需指定两个参数 ：'name 和 oflag'.
	O_CREAT : 如果信号量不存在，则创建一个新的。如果已经存在，则信号量被使用，不会有额外的初始化发生。
	O_EXCL : 当指定为 O_CREAT | O_EXCL 时，如果信号量已存在，则返回错误 EEXIST.

@ mode & value :
	当 oflag 指定为 'O_CREAT' 时，这两个参数必须指定.
	@ mode : 表示信号量的访问权限，它的取值和打开文件的权限位相同；
	@ value : 在创建信号量时，用来指定信号量的初始值。

@ 返回值：
	成功：返回指向信号量的指针，失败：返回返回 'SEM_FAILED'

   
-------------------------
sem_close() closes the named semaphore referred to by 'sem', allowing any resources that the system has allocated to the calling process for this semaphore to be freed.
        
sem_unlink()  removes  the  named semaphore referred to by 'name'. The semaphore 'name' is removed immediately. The semaphore is destroyed once all other processes that have the semaphore open close it.
*//////////////
```

### 1.3 信号量的操作

使用 `sem_wait` 或 `sem_trywait` 函数来实现对信号量的减 `1` 操作。
使用 `sem_post` 函数使信号量值增 `1`。
`sem_wait` 函数如下： （`P` 操作）

```cpp
NAME
	sem_wait, sem_timedwait, sem_trywait - lock a semaphore

SYNOPSIS
    int sem_wait(sem_t *sem);
    int sem_trywait(sem_t *sem);
    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);

/******** DESCRIPTION ***************

@ desc : 
    sem_wait() decrements (locks) the semaphore pointed to by 'sem'.  If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.

    sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking.

    sem_timedwait() is the same as sem_wait(), except that 'abs_timeout' specifies a limit on the amount of time that the call should block if the decrement cannot be immediately performed. The 'abs_timeout' argument points to a structure that specifies an absolute timeout in seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000(UTC). This structure is defined as follows:
    struct timespec {
        time_t tv_sec;      // Seconds
        long   tv_nsec;     // Nanoseconds [0 .. 999999999]
    };

    If the 'timeout' has already expired by the time of the call, and the semaphore could not be locked immediately, then sem_timedwait() fails with a timeout error  (errno  set to ETIMEDOUT).
    If the operation can be performed immediately, then 'sem_timedwait()' never fails with a timeout error, regardless of the value of 'abs_timeout'.  Furthermore, the validity of 'abs_timeout' is not checked in this case.

@ 返回值 ：
	成功返回 0，失败返回 -1，信号量的值将不被改变。
***********/
```

`sem_post` 函数如下：（`V` 操作）

```c
NAME
	sem_post - unlock a semaphore

SYNOPSIS
	#include <semaphore.h>

	int sem_post(sem_t *sem);


/*****DESCRIPTION
@ desc :
	sem_post()  increments  (unlocks) the semaphore pointed to by 'sem'.  If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore.

@ RETURN VALUE : 
	sem_post() returns 0 on success; on error, the value of the semaphore is left unchanged, -1 is returned, and errno is set to indicate the error.
*///////////////

```



## 2. 互斥量 (`mutex`)

互斥量本质是一把锁，用来确保同一时间只有一个线程访问数据。在访问共享资源前对互斥量进行加锁，在访问完成后释放互斥量。
对互斥量加锁后，任何试图再次对互斥量加锁的线程都会被阻塞直到当前线程释放该互斥锁。
互斥量是用 `pthread_mutex_t` 数据类型表示的，在使用互斥量之前，必须对它进行初始化。

以下是互斥锁的相关操作函数：

```c

NAME
	pthread_mutex_init, pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock, pthread_mutex_destroy - operations on mutexes

SYNOPSIS
	#include <pthread.h>
	
	pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;
	pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
	pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
	
	int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
	int pthread_mutex_destroy(pthread_mutex_t *mutex);
	int pthread_mutex_lock(pthread_mutex_t *mutex);
	int pthread_mutex_trylock(pthread_mutex_t *mutex);
	int pthread_mutex_unlock(pthread_mutex_t *mutex);


//-----------------------------
这组函数的返回值
    @ RETURN VALUE：
	成功 0，失败 -1

@ desc :
        'pthread_mutex_init' initializes the mutex object pointed to by 'mutex' according to the mutex attributes specified in 'mutexattr'. If 'mutexattr' is NULL, default attributes are used instead.

@ mutex : 要初始化的互斥量

@ mutexattr : 互斥量的属性，默认是 NULL


	如果是动态分配的互斥量，则需要 'pthread_mutex_destroy' 函数销毁该信号量，在进入前该信号量必须是解锁的。

	
//-------------------------	

@ desc:
	'pthread_mutex_lock'
	对给定的互斥量进行加锁。
	如果互斥量已经上锁，调用线程将阻塞直到该互斥量被解锁。
        
//---------------------------			
@ desc ：
    'pthread_mutex_trylock'    
	和函数 pthread_mutex_lock 功能类似，区别是，该函数尝试对互斥量进行加锁，如果互斥量已被加锁，不会阻塞立即返回 EBUSY.
        

//--------------------------
@ desc :
	'pthread_mutex_unlock'
	解锁给定的互斥量。

	

```

## 3. 条件变量

条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以 **无竞争的方式等待特定的条件发生**。条件本身是由互斥量保护的，线程在改变条件状态之前必须首先锁住互斥量。
由 `pthread_cond_t` 数据类型表示的条件变量可以用两种方式进行初始化，用常量 `PTHREAD_COND_INITIALIZER` 赋值给静态分配的条件变量，而对于动态分配的条件变量，则使用 `pthread_cond_init` 函数对它进行初始化。

```c
NAME
	pthread_cond_init, pthread_cond_destroy, pthread_cond_signal, pthread_cond_broadcast, pthread_cond_wait, pthread_cond_timedwait - operations on conditions
    
SYNOPSIS
	#include <pthread.h>
	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
	
	int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cond_attr);
    int pthread_cond_signal(pthread_cond_t *cond);

    int pthread_cond_broadcast(pthread_cond_t *cond);

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

    int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);

    int pthread_cond_destroy(pthread_cond_t *cond);

////------------------------------
	@ desc :
		用来初始化条件变量
	@ cond : 初始化的条件变量
	@ cond_attr : 条件变量的属性，默认是 NULL
	@ 返回值 ： 成功 0， 失败 -1

	'pthread_cond_init' initializes the condition variable 'cond', using the condition attributes specified in 'cond_attr', or default attributes if 'cond_attr' is NULL. The LinuxThreads implementation supports no attributes for conditions, hence the cond_attr parameter is actually ignored.
        
//----------------------------------
	@ desc :
		用于通知线程条件已满足。唤醒任意一个等待条件变量的线程。
	'pthread_cond_signal' restarts one of the threads that are waiting on the condition variable 'cond'. If no threads are waiting on 'cond', nothing happens. If several threads are waiting on 'cond', exactly one is restarted, but it is not specified which.  
    @ 返回值 ：成功 0，失败 -1
            
//----------------------------------    
    @ desc :
		广播通知所有等待条件变量的线程。	
	'pthread_cond_broadcast' restarts all the threads that are waiting on the condition variable cond. Nothing happens if no threads are waiting on cond.
    
 //--------------------------------
	@ desc : 
		等待条件变量变为真。参数 'mutex' 是用于对条件变量保护的互斥锁。在调用 'pthread_cond_wait' 前，必须确保对互斥量已加锁。
		调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，然后对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。'pthread_cond_wait' 返回时，互斥量再次被锁住。
		'pthread_cond_wait' atomically unlocks the 'mutex' (as per pthread_unlock_mutex) and waits for the condition variable 'cond' to be signaled. The thread execution is suspended and does not consume any CPU time until the condition variable is signaled. The mutex must be locked by the calling thread on entrance to 'pthread_cond_wait'. Before returning to the calling thread, pthread_cond_wait re-acquires mutex (as per pthread_lock_mutex).

//--------------------
            
'pthread_cond_destroy'  destroys a condition variable, freeing the resources it might hold. No threads must be waiting on the condition variable on entrance to pthread_cond_destroy. In the LinuxThreads implementation, no resources are associated with condition variables, thus pthread_cond_destroy actually does nothing except checking that the condition has no waiting threads.

```

