- [进程间的通信方式](#进程间的通信方式)
  - [1. 管道](#1-管道)
    - [(1) . 管道操作函数：`pipe`，`fork`](#1--管道操作函数pipefork)
    - [(2).  管道代码](#2--管道代码)
    - [(3). 命名管道 ：`FIFO`](#3-命名管道-fifo)
  - [2. 消息队列](#2-消息队列)
    - [(1).  消息队列是存在于内核中的消息链接表](#1--消息队列是存在于内核中的消息链接表)
    - [(2) . 创建队列：`ftok`，`msgget`](#2--创建队列ftokmsgget)
    - [(3) . 消息队列操作：`msgsnd`，`msgrcv`](#3--消息队列操作msgsndmsgrcv)
    - [(4) . 消息队列控制：`msgctl`](#4--消息队列控制msgctl)
    - [(5) . 代码示例](#5--代码示例)
  - [3. 共享内存](#3-共享内存)
    - [(1) . 共享内存允许两个进程或多个进程共享一个给定的存储区。因为数据不需要在进程间复制，所以这是最快的一种 `IPC` 通信。](#1--共享内存允许两个进程或多个进程共享一个给定的存储区因为数据不需要在进程间复制所以这是最快的一种-ipc-通信)
    - [(2) . 创建或打开共享存储区：`shmget`](#2--创建或打开共享存储区shmget)
    - [(3) . 共享存储段操作：`shmctl`](#3--共享存储段操作shmctl)
    - [(4) . 共享内存的操作 ：`shmat`，`shmdt`](#4--共享内存的操作-shmatshmdt)
    - [(5) . 代码](#5--代码)
  - [4. 信号量](#4-信号量)
    - [(1) . `XSI`信号量](#1--xsi信号量)
    - [(2) . 创建信号量集合  **`semget`**](#2--创建信号量集合--semget)
    - [(3) .  信号量控制： `semctl`](#3---信号量控制-semctl)
    - [(4) . 信号量操作 ：`semop`执行信号量集合上的操作数组。](#4--信号量操作-semop执行信号量集合上的操作数组)
    - [(5) . 代码](#5--代码-1)
  - [5. `socket `通信](#5-socket-通信)

# 进程间的通信方式

<img src="../pics/process.png" style="zoom:80%;" />



## 1. 管道

两个进程间可以通过管道进行通信，但由两个局限性：

-   数据只能单向传输（半双工管道）；
-   管道只能在具有公共祖先的两个进程之间使用（亲属关系）。

其中有名管道 `FIFO `不存在第二个缺陷。

### (1) . 管道操作函数：`pipe`，`fork`

管道通过系统调用 **`pipe`** 函数创建：**`pipe()`** 创建一个用于进程间通信的单向数据通道。创建成功的管道是内核中的一段缓冲区，不同的进程通过内核进行通信。

```cpp
#include <unistd.h>

int pipe(int pipefd[2]);

/*
	@ pipefd[0] : 指向读端，pipefd[1] : 指向写端。
	@ 返回值：成功返回 0，失败返回 -1。
*/

```

![](../pics/pipe.png)



单个进程中的管道几乎没有任何用处。通常，进程先调用 **`pipe`** 创建管道，然后调用 **`fork`**，父子进程分别引用计数于管道。从而可以创建从父进程到子进程的 **`IPC`** 通道。如下图所示：

![](../pics/pipe_fork.png)



当 **`fork`** 后做什么取决于我们想要的数据流方向。对于从父进程到子进程的管道，父进程关闭读端 ( `fd[0] `)，子进程关闭写端 (` fd[1]` )。如下图所示：

![](../pics/pipe_fork1.png)

### (2).  管道代码

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main( int argc, char *argv[] )
{
    
    int fd[2];
    pid_t pid;
    
    char buf;
    
   	if( argc != 2 )
    {
        fprintf(stderr, "Usage: %s <string>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    if( pipe(fd) == -1 )
    {
        perror("pipe");
        exit(EXIT_FAILURE);
    }
    
    pid = fork();
    
    if( pid == -1 )
    {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    
    if( pid == 0 )	/* Child read from pipe */
    {
        close(fd[1]);	// close write end
        while( read(fd[0], &buf, 1) > 0 )
        {
            write( STDOUT_FILENO, &buf, 1 );
        }
        
        write( STDOUT_FILENO, "\n", 1 );
        close(fd[0]);
        exit(EXIT_SUCCESS);
        
    }
    else	// pid > 0: parent write argv[1] to pipe
    {
        close(fd[0]);
        write( fd[1], argv[1], strlen(argv[1]) );
        close(fd[1]);	// 
        wait(NULL);		// wait for child process exit
        exit(EXIT_SUCCESS);
    }
    return 0;
    
}
```

### (3). 命名管道 ：`FIFO`

无名管道只能在两个相关的进程间使用，且这两个相关的进程还要有一个共同创建了它们的祖先进程。然而，通过 `FIFO `，不相关的进程也可以进行通信，并且可以用于多个进程间的通信。`shell `命令就是使用 **`FIFO`** 将数据从一条管道传送到另一条，无需创建中间临时文件。 

`FIFO `是一种文件类型。操作命名管道类似于普通文件的读写操作。通过系统函数 **`mkfifo()`** 来创建有名管道，它是以 `p `类型开头的管道文件。

![](../pics/fifo.png)

但是在对管道进行任何读写操作前，通信双方必须同时打开管道。

```c
NAME
	mkfifo, mkfifoat - make a FIFO special file( a named pipe )

SYNOPSIS
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    int mkfifo( const char *pathname, mode_t mode );
	
    int mkfifoat(int dirfd, const char *pathname, mode_t mode);

/*
	@ 返回值 : 成功返回 0，失败返回 -1 并设置 errno
	@ pathname : 指定的文件上创建有名管道
	@ mode ：管道的权限
*/
```

`code `：` fifo_write.c` 和 `fifo_read.c`

综上，管道的通信方式较低效，不适合进程间频繁的数据交流。

## 2. 消息队列

**`XSI`** 接口是 **`POSIX`** 标准定义的一组可选系统接口。

`XSI IPC` 函数是紧密基于 `System V` 的 `IPC `函数的。有 3 种 `XSI` 的 `IPC` 函数：消息队列、信号量、共享内存。可以使用命令 `ipcs `和 `ipcrm `来管理 `IPC `对象。
操作消息队列的命令是 ：
查看：`ipcs -q`；
删除：`ipcrm -q id` （`id` 消息队列编号）。

### (1).  消息队列是存在于内核中的消息链接表

消息队列在内核中用一个非负整数的标识符来引用，因此，在一个消息队列中传递信息时，只需要知道其队列标识符即可。标识符只是 **`IPC`** 对象的内部名，为使多个合作进程可以在同一 **`IPC`** 对象上汇聚，需要提供一个外部命名方案。因此，每个 **`IPC`** 对象都与一个键相关联，将这个键作为该对象的外部名。消息队列通过调用 **`msgget`** 来创建对应的 **`IPC`** 结构，但需要给 **`msgget`** 指定一个键，这个键由内核变成对应的 `IPC `结构标识符。  

每个消息是一个独立的数据块，包括：一个正的长整型类型的字段、一个非负的长度以及实际的数据字节数。

每个队列都有一个 `msqid_ds `结构与其关联：

```c
The msqid_ds data structure is defined in <sys/msg.h> as follows:

struct msqid_ds {
    struct ipc_perm msg_perm;     /* Ownership and permissions */
    time_t          msg_stime;    /* Time of last msgsnd(2) */
    time_t          msg_rtime;    /* Time of last msgrcv(2) */
    time_t          msg_ctime;    /* Time of last change */
    unsigned long   __msg_cbytes; /* Current number of bytes in queue (nonstandard) */
    msgqnum_t       msg_qnum;     /* Current number of messages in queue */
    msglen_t        msg_qbytes;   /* Maximum number of bytes allowed in queue */
    pid_t           msg_lspid;    /* PID of last msgsnd(2) */
    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
};

The ipc_perm structure is defined as follows (the highlighted fields are settable using IPC_SET):

struct ipc_perm {
    key_t          __key;       /* Key supplied to msgget(2) */
    uid_t          uid;         /* Effective UID of owner */
    gid_t          gid;         /* Effective GID of owner */
    uid_t          cuid;        /* Effective UID of creator */
    gid_t          cgid;        /* Effective GID of creator */
    unsigned short mode;        /* Permissions */
    unsigned short __seq;       /* Sequence number */
};

```



### (2) . 创建队列：`ftok`，`msgget`

**`msgget`** ：创建一个新队列或打开一个现有队列。
**`ftok`** 函数提供唯一的服务就是把一个路径名和项目 `ID ` 产生一个键。首先通过调用 **`ftok`** 产生一个 `key `。 该函数原型如下：

```c
#include <sys/ipc.h>
key_t ftok( const char *path, int id );

/*
	@ path ：必须存在的路径名
	@ id : 用户自定义
	@ 返回值：
        成功返回：一个由内核生成的key, 是定义在 sys/types.h 中的一个长整型
        失败返回：-1。
*/
```

**`msgget`** 函数原型如下：

```c
NAME
       msgget - get a System V message queue identifier

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgget(key_t key, int msgflg);

/*
	@ desc ：
		当 key 值不是 IPC_PRIVATE 且 msgflg 是 0 时，表示引用一个现有的消息队列；
		当 key 值不是 IPC_PRIVATE 且 给定的 key 没有关联到已有的消息队列时，msgflg 指定为IPC_CREAT, 则创建一个消息队列。
	
	@ key : 由 ftok 函数生成的外部名 key，而不是使用 IPC_PRIVATE。当 key 使用 IPC_PRIVATE，总是创建一个新的消息队列。
	
	@ msgflg : 标记位设置。ipc_perm 结构中的 mode 由 msgflg 来设置初始化。
		想要创建一个新队列时，要指定 IPC_CREAT。
		当使用 IPC_CREAT | IPC_EXCL 时, 若给定的 key 已有关联的消息队列，则返回失败并设置 errno 为 EEXIST。
		若没有指定 IPC_EXCL，当 key 已关联消息队列，则会引用现有的消息队列。
	Usage: IPC_CREAT | 权限位，如 IPC_CREAT | 0666。
	
	@ 返回值：
		成功返回：队列标识符ID（一个非负整数）
    	失败返回：-1.
	
		当函数成功返回时，会初始化控制消息队列的结构体 msqid_ds 中的相关数据。
		• msg_perm.cuid and msg_perm.uid are set to the effective user ID of the calling process.
		• msg_perm.cgid and msg_perm.gid are set to the effective group ID of the calling process.

		• The least significant 9 bits of msg_perm.mode are set to the least significant 9 bits of msgflg.

		• msg_qnum, msg_lspid, msg_lrpid, msg_stime, and msg_rtime are set to 0.

		• msg_ctime is set to the current time.

		• msg_qbytes is set to the system limit MSGMNB.
*/

```



所以，先调用 **`ftok`** 函数 生成一个键 **`key`**，然后传给 **`msgget`** 函数来创建或引用一个消息队列。



### (3) . 消息队列操作：`msgsnd`，`msgrcv`

**`msgsnd`** 用于向消息队列发送消息，**`msgrcv`** 用于从消息队列中取出消息。具体函数如下：

```c
NAME
       msgrcv, msgsnd - System V message queue operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/ipc.h>
       #include <sys/msg.h>

       int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
		
/*
	@ desc：
		每次追加一个由 msgp 指定消息体到队列 msgid 的尾部。
	
	@ msqid: msgget函数的返回队列ID
	@ msgp: 指向要发送的消息体，它定义的通用结构如下：
	
        struct msgbuf {
            long mtype;        // message type, must be > 0 
            char mtext[1];     // message data, 自定义大小 
        };
        mtype：必须为正整数，在接收端可以被用来指定要接收哪个数据包
        mtext是一个字符数组，保存用户想要发送的数据，数组的大小由msgsz指定。当没有 mtext 数据域时，表示消息长度为0。
    
    @ msgsz : 指定mtext字符数组的大小，可以为0。
    @ msgflg: 标记位。
    	当消息队列没有可用空间时，默认阻塞直到空间可用。
        IPC_NOWAIT ： 若消息队列已满，立即失败返回设置 errno 为 EAGAIN 。
    @ return value
    	成功: 0
    	失败: -1, 
        
*/
       ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,
                      int msgflg);
/*
	从给定的消息队列中移除消息，并且放在 msgp 中。
	@ msqid : 消息队列ID 
	@ msgp : 指向存放消息体的缓冲区
	@ msgsz : msgp 结构中成员 mtext 的大小
	@ msgtyp ：
		== 0 : 消息队列中的第一个消息被读取;
		> 0 : 则读取消息队列中等于 mtype 的第一个消息体; 这样就可以实现非先进先出次序读取消息。
		< 0 : 取 msgtyp 的绝对值，然后读取 小于等于 其绝对值的最小类型的消息体。
	@ msgflg : 
		IPC_NOWAIT: 当队列为空时，则立即失败返回设置 errno 为 ENOMSG。否则，一直阻塞到队列中有消息可读。
		MSG_NOERROR: 当 mtext 的大小 大于 msgsz，则截断读取消息。若没有指定 MSG_NOERROR, 则会因为消息太长导致读取消息失败（消息不会从队列中移除），  返回-1并设置errno 为 E2BIG.
	@返回值：
        失败：返回-1
        成功：返回实际复制到mtext数组中的字节数
	
*/

```



### (4) . 消息队列控制：`msgctl`

对队列执行多种操作。

```c
NAME         
       msgctl - System V message control operations
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/msg.h>
       int msgctl(int msqid, int cmd, struct msqid_ds *buf);

/*
	@ msgid : 消息队列ID
	@ cmd
		IPC_STAT: 读取队列 msqid_ds 结构，并把它放入由 buf 指定的结构中。 
		IPC_SET:  将 buf 指向的结构中的一些数据写入内核中的 msqid_ds 结构中。更新的数据为
			msg_qbytes, msg_perm.uid, msg_perm.gid, and (the leastsignificant 9 bits of) msg_perm.mode。
			
		IPC_RMID: 从系统中删除消息队列以及仍在该队列中的所有数据。这种删除立即生效
*/

```

### (5) . 代码示例

`msg `文件夹 

## 3. 共享内存

### (1) . 共享内存允许两个进程或多个进程共享一个给定的存储区。因为数据不需要在进程间复制，所以这是最快的一种 `IPC` 通信。

共享内存的操作命令：
查看：`ipcs -m`；删除：`ipcrm -m id`。

使用共享存储时掌握的唯一窍门就是：在多个进程间同步访问一个给定的存储区。
例如，在服务器进程正在将数据写入共享存储区，在完成这一操作前，客户进程不应去读取这些数据。通常信号量用于 **同步访问共享存储区**。
**`XSI`** 共享存储和内存映射的文件的不同在于，前者没有相关的文件。**`XSI`** 共享存储段是内存的匿名段。

内核为每个共享存储段维护一个数据结构用于表示共享内存的信息：该数据结构定义在 `<sys/shm.h>`。其中一个重要的参数为 `shm_nattch`，表示该共享段有多少个进程引用。

```c
struct shmid_ds {
    struct ipc_perm shm_perm;    /* Ownership and permissions */
    size_t          shm_segsz;   /* Size of segment (bytes) */
    time_t          shm_atime;   /* Last attach time */
    time_t          shm_dtime;   /* Last detach time */
    time_t          shm_ctime;   /* Last change time */
    pid_t           shm_cpid;    /* PID of creator */
    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
    shmatt_t        shm_nattch;  /* No. of current attaches */
    ...
};


```

### (2) . 创建或打开共享存储区：`shmget`

```c
NAME
       shmget - allocates a System V shared memory segment

SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmget(key_t key, size_t size, int shmflg);

/*
	@ desc
		shmget函数返回一个和 key 相关的共享内存标识符ID;
	
	@ key 
		IPC_PRIVATE: 创建一个共享存储段
	@ size
		创建的共享存储段的大小，以字节为单位。创建一个新的共享存储段时，必须指定为正整数。当引用一个现有段时，则指定为0.
	@ shmflg
		IPC_CREAT : 创建共享存储段
	
	@ RETURN VALUE
		成功: 一个有效的共享存储段 ID
		失败：-1


*/
```

### (3) . 共享存储段操作：`shmctl`

**`shmctl`** 对共享存储段执行多种操作

```c
NAME
       shmctl - System V shared memory control

SYNOPSIS
       #include <sys/ipc.h>
       #include <sys/shm.h>

       int shmctl(int shmid, int cmd, struct shmid_ds *buf);

/*
	@ desc
		通过 cmd 命令对共享存储段进行控制操作
	
	@ shmid
		共享存储段的ID
	@ cmd
		IPC_STAT: 获取内核中的共享存储段的 shmid_ds 结构，并存储到 buf 中
		IPC_SET : 将 buf 指向的结构中的值设置为与此共享段相关的 shmid_ds 结构中
		
		IPC_RMID : 从系统中删除该共享内存段。
		每个共享内存段维护着一个连接计数( shmid_ds 中的 shm_nattch 字段)，所以只有当该段的最后一个进程终止或与该段分离（计数此时为 0 ），则该段才会最		终被删除。删除后不能再用 shmat 与 该段连接。
	
	@ return value
		成功 ： 依据不同的命令返回不同，大部分返回0
		失败 : -1
*/
```

### (4) . 共享内存的操作 ：`shmat`，`shmdt`

当成功创建共享内存后，进程可以调用 **`shmat`** 将该共享段连接到它的地址空间中。而 **`shmdt`** 负责进程与该共享段分离。

```c
NAME
       shmat, shmdt - System V shared memory operations

SYNOPSIS
       #include <sys/types.h>
       #include <sys/shm.h>

       void *shmat(int shmid, const void *shmaddr, int shmflg);
	
/*
	@ desc
		shmat 负责连接由 shmid 执行的共享存储段到调用进程的地址空间中。
	@ shmid
		创建好的共享存储段id
	@ shmaddr
		表示将共享存储段连接到调用进程的哪个地址上。
		通常指定为 0, 则表示由内核做出选择，内核会把该段连接到进程的第一个可用地址上。
	@ shmflg
    	通常指定为 0
    
    @ return value
  		成功：该共享段所连接的实际地址。另外，内核将使与该共享段相关的 shmid_ds 结构中的 shm_nattch 计数器加 1。
  		失败：(void *)-1
*/

	int shmdt(const void *shmaddr);
/*
	@ desc
		解分离
	@ shmaddr
		shmat 的返回值。
	@ return value
		成功 ： 0
		是被 ： -1
*/
```

 当对该共享段的操作以结束时，则调用 **`shmdt`** 与该段分离，同时 `shm_nattch `值 减 1。但不会从系统中删除该共享标识符。

### (5) . 代码

`shm `文件夹

## 4. 信号量

信号量是一个计数器，用于为多进程提供对共享数据对象的访问

为了获得共享资源，进程需要执行以下操作：

1.  测试控制该资源的信号量；
2.  若此信号量为正，则进程可以使用该资源。在这样情况下，进程会将信号量减 1，表示它使用了一个资源单位；`---> P` 操作
3.  若此信号量为 0，则进程进入休眠状态，直至信号量值大于 0。当进程被唤醒后，转入步骤 1。
4.  当进程释放由一个信号量控制的共享资源时，该信号量增 1。如果有进程正在休眠等待此信号量，则唤醒他们。`---> V` 操作

为了正确地实现信号量，信号量值的增 1 操作及减 1 操作应当是原子操作。因此，信号量通常在内核中实现。

常用的信号量形式被称为二元信号量。它控制单个资源，其初始值为 1 。我们把访问某种共享资源的代码块称为 "临界区" 。

### (1) . `XSI`信号量

信号量的操作命令：
查看：`ipcs -s`；删除：`ipcrm -s id`。

`XSI `信号量实现较复杂。原因如下：

-   信号量并非单个非负值，而是必须定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量。
-   信号量的创建 ( `semget `) 是独立于它的初始化的 ( `semctl `) 。这是一个致命的缺点，因为不能原子地创建一个信号量集合，并对该集合中的各个信号量值赋初值。
-   即使进程没有使用各种形式的 `XSI IPC`，它们仍然是存在的。

内核为每个信号量集合维护一个 `semid_ds `数据结构，如下：

```c
The semid_ds data structure is defined in <sys/sem.h> as follows:

           struct semid_ds {
               struct ipc_perm sem_perm;  /* Ownership and permissions */
               time_t          sem_otime; /* Last semop time */
               time_t          sem_ctime; /* Creation time/time of last
                                             modification via semctl() */
               unsigned long   sem_nsems; /* No. of semaphores in set */
           };

       The fields of the semid_ds structure are as follows:

       sem_perm
              This is an ipc_perm structure (see below) that specifies
              the access permissions on the semaphore set.

       sem_otime
              Time of last semop(2) system call.

       sem_ctime
              Time of creation of semaphore set or time of last semctl()
              IPCSET, SETVAL, or SETALL operation.

       sem_nsems
              Number of semaphores in the set.  Each semaphore of the
              set is referenced by a nonnegative integer ranging from 0
              to sem_nsems-1.
           
The ipc_perm structure is defined as follows (the highlighted fields are settable using IPC_SET):

    struct ipc_perm {
        key_t          __key; /* Key supplied to semget(2) */
        uid_t          uid;   /* Effective UID of owner */
        gid_t          gid;   /* Effective GID of owner */
        uid_t          cuid;  /* Effective UID of creator */
        gid_t          cgid;  /* Effective GID of creator */
        unsigned short mode;  /* Permissions */
        unsigned short __seq; /* Sequence number */
    };
```



### (2) . 创建信号量集合  **`semget`**

```c
NAME         
       semget - get a System V semaphore set identifier
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semget(key_t key, int nsems, int semflg);

/*
	@ desc
		创建一个新信号量集合或引用一个现有集合。
	@ key : ftok 函数生成的键 key
	@ nsems ：创建的信号量集合中信号量的个数，此时 nsems 必须大于 0。如果为 0，则表示引用一个现有集合。
	@ semflg: IPC_CREAT 指定创建一个新信号量集合。
	@ return value:
		成功 ： 信号量集合ID;
		失败 ： -1
	@ other
		When creating a new semaphore set, semget() initializes the set's
       associated data structure, semid_ds (see semctl(2)), as follows:

       • sem_perm.cuid and sem_perm.uid are set to the effective user ID
         of the calling process.

       • sem_perm.cgid and sem_perm.gid are set to the effective group
         ID of the calling process.

       • The least significant 9 bits of sem_perm.mode are set to the
         least significant 9 bits of semflg.

       • sem_nsems is set to the value of nsems.

       • sem_otime is set to 0.

       • sem_ctime is set to the current time.
*/
```

### (3) .  信号量控制： `semctl`

**`semctl`** 对集合上的多个信号量进行控制，即对集合中的信号量进行初始化。

```c
NAME        
    semctl - System V semaphore control operations  
SYNOPSIS        
    #include <sys/types.h>        
    #include <sys/ipc.h>        
    #include <sys/sem.h>         
    int semctl(int semid, int semnum, int cmd, ...); 

/*
	@ desc
		对信号量集合中的全部信号量或者编号为 semnum 的特定信号量进行操作，具体操作由 cmd 命令指定。集合中的信号量从 0 开始编号。
		这个函数根据 cmd 命令有 3 个或 4 个参数，第 4 个参数的结构如下：
		 union semun {                
		 	int              val;    // Value for SETVAL              
			struct semid_ds *buf;    // Buffer for IPC_STAT, IPC_SET              
			unsigned short  *array;  // Array for GETALL, SETALL               
			struct seminfo  *__buf;  // Buffer for IPC_INFO (Linux-specific)       
		};
		
	@ semid ： 集合标识符
	@ semnum : 指定集合中的一个成员，semnum 的值位于 [0, nsems-1] 区间内
	@ cmd 
		IPC_STAT : 复制内核中的集合的属性到 arg.buf 中;
		IPC_SET ：将 arg.buf 中的一些属性写入到内核中的集合属性;
		IPC_RMID ：从系统中立即删除信号量集合，参数 semnum 将被忽略;
		GETVAL ：返回成员 semnum 的 semval 值;
		SETVAL ：设置成员 semnum 的 semval 值，该值由 arg.val 指定
	
	@ return value
		失败：-1
		成功：所有GET命令除GETALL外，semctl 函数返回对应的值。其他命令返回 0。

*/

```

### (4) . 信号量操作 ：`semop`执行信号量集合上的操作数组。

**`semop`** 函数具有原子性。它要么全部执行操作数组中的所有操作，要么一个也不做。

```c
NAME         
       semop, semtimedop - System V semaphore operations
SYNOPSIS         
       #include <sys/ipc.h>
       #include <sys/sem.h>

       int semop(int semid, struct sembuf *sops, size_t nsops);
       int semtimedop(int semid, struct sembuf *sops, size_t nsops,
                      const struct timespec *timeout);

   Feature Test Macro Requirements for glibc (see
   feature_test_macros(7)):

       semtimedop():
           _GNU_SOURCE
               
Each semaphore in a System V semaphore set has the following associated values:             
    unsigned short  semval;   /* semaphore value */            
    unsigned short  semzcnt;  /* # No. of process waiting for zero */            
    unsigned short  semncnt;  /* # No. of process waiting for increase */           
    pid_t           sempid;   /* PID of process that last 
    
/*
	@ desc
		由 sops 指定的数组中的每个元素表明对一个信号量的具体操作，sops 数组大小为 nsops。数组中的每个元素是如下的结构：
		struct sembuf
		{
			unsigned short sem_num;  // semaphore number 
			short sem_op;   // semaphore operation 
			short sem_flg;  // operation flags 

		}
		@ sem_num : 指定的要操作的信号量编号
		@ sem_op : 对信号量的具体操作
			> 0 : 进程释放占用的资源。操作会增加 semval 的值; 如果操作中 SEM_UNDO 被指定，则系统将从该信号量调整值中减去值 sem_op。
			== 0 ：调用进程希望等待到该信号量值变成 0, 如果为 0, 那么函数立即返回，进程继续执行。否则默认是阻塞的; 如果指定了 IPC_NOWAIT, 则不阻塞立					即失败返回。 
			< 0 : 要获取由该信号量控制的资源。
				如果 semval 大于等于 sem_op 的绝对值，操作立即执行，并从信号量中减去 sem_op 的绝对值。如果指定了 SEM_UNDO, 系统将 sem_op 的绝对值				  加到该信号量调整值上。如果 sem_op 的绝对值大于 semval 的值，若指定了 IPC_NOWAIT, 则进程不阻塞立即返回并设置 errno 为 EAGAIN。否					则，该进程一直阻塞直到以下条件中的任一个发生：
				1. 资源可用;
				2. 信号量集合从系统中被移除，设置 errno 为 EIDRM;
				3. 调用进程捕捉到一个信号，
		@ sem_flg : 标记位
			IPC_NOWAIT : 进程不阻塞等待所申请的资源;
			SEM_UNDO : 如果进程意外终止，则归还进程持有的信号量资源。
	
	@ semid : 集合ID
	@ sops : 操作数组
		用来指定对集合中的信号量要执行的操作。按数组顺序执行的一组原子操作。
	@ nsops : 操作数组的大小
	@ return value
		成功 ：0
		失败 ：-1。
*/
```

### (5) . 代码

`sem `文件夹

## 5. `socket `通信

