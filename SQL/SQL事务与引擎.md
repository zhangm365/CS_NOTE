[toc]

# SQL事务与引擎

## 1.  MySQL 事务与引擎

### (1) . 事务

事务是数据库中的一组操作，事务内的这组操作要么全部成功，要么全部失败，不允许部分操作完成。

事务有原子性、一致性、隔离性、持久性四个特性。

1. InnoDB 引擎是 MySQL 默认的事务型存储引擎，MyISAM 引擎不支持事务。MySQL 支持四个事务隔离级别：
    -   读未提交：一个事务还没提交，它做的变更就能被其他事务看到；
    -   读提交：一个事务提交之后，它做的变更才可以被其他事务看到；
    -   可重复读：一个事务在执行过程中所看到的数据，总是跟这个事务启动时看到的数据是一致的。
    -   串行化：对于同一行记录，写操作会加 "写锁" ，读操作会加 "读锁"。当读写锁发生冲突时，后访问的事务必须等前一个事务执行完成，才可以继续执行。

MySQL默认的事务隔离级别是**可重复读**。在可重复隔离级别下，通过多版本并发控制 (MVCC) + Next-Key Lock 防止幻影读。

隔离级别：串行化 > 可重复读 > 读提交 > 读未提交 

隔离级别越高，事务操作的性能就越低。



### (2) . 事务并发可能出现的情况

​	

```mysql
mysql> CREATE TABLE city(
     id int(10) auto_increment,
     name varchar(30),
     primary key (id)
     )engine=innodb charset=utf8mb4;

mysql> INSERT INTO city(name) values('武汉市');


mysql> select * from city;
+----+-----------+
| id | name |
+----+-----------+
| 1 | 武汉市 |
+----+-----------+
```



-   脏读：一个事务读到了另一个事务未提交的更改数据，之后未提交的事务执行回滚操作。(脏读只在读未提交隔离级别才会出现）



![](pictures\dirty_read.png)

>   会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。

​	

-   不可重复读：一个事务只能读到另一个已经提交事务的修改数据，并且其他事务每对该数据进行一次更改并提交后，该事务都能查询到最新值。(不可重复读会出现在读未提交、读提交的隔离级别中)

    ![](.\pictures\N_read.png)

>   会话A开启一个事务，查询 id=1 的结果为武汉市。接着会话B修改 id=1 的name值为温州市(隐式事务，因为此时 autocommit 为1，每条 SQL 语句执行完自动提交)，此时事务A再次查询 id=1 的结果值为温州市；会话B继续修改 id=1 的name值为杭州市，此时事务A查询 id=1 的结果值为杭州市。所以，在同一个事务执行过程中，对同一组数据的读取结果不一致，这种现象就是不可重复读。



-   幻读：一个事务的某次 select 操作得到的结果所表征的数据状态无法支撑后续的事务操作。具体描述：事务 A 查询某记录是否存在，当不存在时，准备插入此记录。但之后另一个事务 B 向表中插入此记录。当原先的事务执行相同的插入操作时，会出现无法插入的现象，这样情况称为幻读。(幻读可能在读未提交、读提交、可重复读的隔离级别中出现)

    >   如下图： MySQL中默认的隔离级别为可重复读
    >
    >   ![](pictures\pha_1.png)
    >
    >   会话A开启一个事务，查询 id == 1 的记录，此时只查到空记录。接着会话B插入一条 id = 1 的数据 ( INSERT 后提交），这时会话A的事务再以刚才的查询条件（id == 1）再一次查询，此时还是空记录，而当事务 A 执行插入 id = 1 的操作时，会出现错误。这种现象就是幻读，即某次 select 操作得到的结果所表征的数据状态无法支撑后续的事务操作。
    >
    >   ​	
    >
    >   ​	例如： 事务 A 的操作：
    >
    >   ![](.\pictures\pha_2.png)
    >
    >   
    >
    >     例如：事务 B 的操作：
    >
    >   ![](.\pictures\pha_3.png)
    >
    >   
    >
    >   
    >
    >   



### (3) . 四种隔离级别比较

![](pictures\four_isolate.png)

### (4) . 多版本并发控制 ( MVCC )

mvcc 是 InnoDB 的事务型隔离级别下的一种增强并发性的强大技术。它使得事务在执行一致性读操作有了保证。即，为了查询一些正在被另一个事务更新的行，可以保证读到被更新前的值。

### (5) . 等价性判断原则

-   版本未提交，不可见；
-   版本已提交，但是在快照创建后提交的，不可见；
-   版本已提交，但是在快照创建前提交的，可见。

### (6) . 并发控制

事务的并发可能会导致数据的不一致性，所以，对事务进行并发控制非常重要。数据库中提供了两种类型的锁组成的锁系统来解决并发控制。

1.  按读写

    共享锁 ( shared lock ) ：又称读锁，S锁。读锁是共享的，相互不阻塞的。多个客户可以同时读取同一个资源，而互不干扰。

    排他锁 ( exclusive lock ) ：又称写锁，X锁。写锁是排他的，会阻塞其他读锁或写锁。只有获得写锁的事务才可以执行写入操作，防止其他事务同时读取或写入。

2.  按锁粒度

    表锁：MySQL 中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。

    行级锁：最大程度地支持并发处理。开销较大，并发度高。

### (7) . 快照读和当前读

快照读：读取的快照版本，就是历史版本。普通的 select 就是快照读；

当前读：读取的最新版本。update，insert，delete，select ... lock in share mode，select ... for update 是当前读。

### (8) . 锁定读和一致性非锁定读

锁定读：一个事务中，默认的 select 操作是不加锁的。但是由两个例外情况：select ... lock in share mode 和 select ... for update 。

select ... lock in share mode ：给表或记录加共享锁，其他事务只能读不能修改，直至当前事务提交；

select ... for update ：更 update 操作加锁一样的情况。

一致性非锁定读：InnoDB 用多版本来提供查询数据库在某个时间点的快照。默认 select 操作就是一致性非锁定读。

