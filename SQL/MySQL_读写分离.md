

[toc]

# 主备架构中的读写分离

-------

## 1. 读写分离

在一主多从的数据库架构中，为了减轻主库的读写压力，可以对业务逻辑请求进行读写分离。在数据库系统中，大部分业务是 **读多写少** 。一主多从的架构模式如下图：

![一主多从架构](.\pictures\27_1.png)

>   图中节点 `A` 和 `A'` 互为主备关系，节点 `B, C, D` 是从库。客户端 `client` 连接在主库 `A` 上进行写需求，而切换到从库 `B, C, D` 库上进行读需求，从而实现读写分离。

## 2. 主备延迟的读写分离

由于主备可能存在延迟，所以，当客户端在主库更新完需求后马上发起查询，而查询选择在从库上进行的，就有可能读不到最新的更新状态，这种情况称为 "过期读"。因此，有以下几种方案可以解决读写分离中的 "过期读" 问题。

### 2.1 强制有主库方案

可以对查询需求进行分类，大致分为以下两类：

1.  必须拿到最新的结果请求，则强制发布在主库上，这样就走主库路线，保证了业务可以读到最新的更新需求；
2.  可以读到旧数据的请求，则发布在从库上，走从库路线。

### 2.2 `sleep` 方案

大部分主备延迟在 `1` 秒内，在从库上可以先 `sleep` 一下大概率可以读到最新数据。具体方案是：执行 `select sleep(1)` 命令。
但是，这个方案不太精确，一方面查询请求可能在 `1` 秒内就可以拿到最新结果，但还是要等 `1` 秒；另一方面，数据延迟超过 `1` 秒，那么还是存在 "过期读"的问题。

### 2.3 判断主备无延迟方案

判断主备库上是否有延迟有以下几种方法：

1.  每次在从库上执行查询请求前，先通过命令 `show replica status` 显示结果中的参数 `seconds_behind_master` 值是否为 `0`，如果不为 `0`，一直等到为 `0` 再执行查询请求。
2.  对比位点确保主备无延迟；
3.  对比 `GTID` 集合确保主备无延迟。


