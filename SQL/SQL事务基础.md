

[toc]

# SQL事务与引擎

----------------------------

## 1.  MySQL 事务与引擎

### (1) . 事务

----------------------

事务是数据库中的一组操作，事务内的这组操作要么全部成功，要么全部失败，不允许部分操作完成。`InnoDB` 引擎中每个事务都有一个唯一`ID`，称为`transaction id`。它在事务启动时向`InnoDB`事务系统申请的，是按申请顺序严格递增的。

#### a. 事务的基本原理 

--------------

事务有原子性、一致性、隔离性、持久性四个特性。（ACID）

1. `InnoDB` 引擎是 `MySQL` 默认的事务型存储引擎，`MyISAM` 引擎不支持事务。`MySQL` 支持四个事务隔离级别：
    -   读未提交：一个事务还没提交，它做的变更就能被其他事务看到；
    -   读提交：一个事务提交之后，它做的变更才可以被其他事务看到；
    -   可重复读：一个事务在执行过程中所看到的数据，总是跟这个事务启动时看到的数据是一致的；
    -   串行化：对于同一行记录，写操作会加 "写锁" ，读操作会加 "读锁"。当读写锁发生冲突时，后访问的事务会被阻塞，必须等前一个事务执行完成后才可以继续执行。

MySQL默认的事务隔离级别是**可重复读**。在可重复隔离级别下，通过多版本并发控制 (MVCC) + Next-Key Lock 防止幻影读。

隔离级别：串行化 > 可重复读 > 读提交 > 读未提交 

隔离级别越高，事务操作的性能就越低。

#### b. 事务的启动与提交

---------

-   在 `MySQL` 中，事务的启动方式有两种。

    第一种：`begin 或 start transaction`，这个命令执行后，并不是一个事务的起点，而在执行后面的第一个操作 `InnoDB` 表的语句后，事务才真正启动。因此，在这种启动方式下，一致性视图是在执行第一个快照读语句时创建的。

    第二种：`start transaction with consistent snapshot` 执行后马上启动一个事务。因此，一致性视图是在执行这个命令时创建的。

-   提交命令：`commit`



### (2) . 事务并发可能出现的情况

​	

```mysql
mysql> CREATE TABLE city(
     id int(10) auto_increment,
     name varchar(30),
     primary key (id)
     )engine=innodb charset=utf8mb4;

mysql> INSERT INTO city(name) values('武汉市');


mysql> select * from city;
+----+-----------+
| id | name |
+----+-----------+
| 1 | 武汉市 |
+----+-----------+
```



-   脏读：一个事务读到了另一个事务未提交的更改数据，之后未提交的事务执行回滚操作。(脏读只在读未提交隔离级别才会出现）



![](pictures\dirty_read.png)

>   会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。

​	

-   不可重复读：一个事务只能读到另一个已经提交事务的修改数据，并且其他事务每对该数据进行一次更改并提交后，该事务都能查询到最新值。(不可重复读会出现在读未提交、读提交的隔离级别中)

    ![](.\pictures\N_read.png)

>   会话A开启一个事务，查询 id=1 的结果为武汉市。接着会话B修改 id=1 的name值为温州市(隐式事务，因为此时 autocommit 为1，每条 SQL 语句执行完自动提交)，此时事务A再次查询 id=1 的结果值为温州市；会话B继续修改 id=1 的name值为杭州市，此时事务A查询 id=1 的结果值为杭州市。所以，在同一个事务执行过程中，对同一组数据的读取结果不一致，这种现象就是不可重复读。



-   幻读：一个事务的某次 select 操作得到的结果所表征的数据状态无法支撑后续的事务操作。具体描述：事务 A 查询某记录是否存在，当不存在时，准备插入此记录。但之后另一个事务 B 向表中插入此记录。当原先的事务执行相同的插入操作时，会出现无法插入的现象，这样情况称为幻读。(幻读可能在读未提交、读提交、可重复读的隔离级别中出现)

    >   如下图： MySQL中默认的隔离级别为可重复读
    >
    >   ![](pictures\pha_1.png)
    >
    >   会话A开启一个事务，查询 id == 1 的记录，此时只查到空记录。接着会话B插入一条 id = 1 的数据 ( INSERT 后提交），这时会话A的事务再以刚才的查询条件（id == 1）再一次查询，此时还是空记录，而当事务 A 执行插入 id = 1 的操作时，会出现错误。这种现象就是幻读，即某次 select 操作得到的结果所表征的数据状态无法支撑后续的事务操作。
    >
    >   ​	
    >
    >   ​	例如： 事务 A 的操作：
    >
    >   ![](.\pictures\pha_2.png)
    >
    >   
    >
    >     例如：事务 B 的操作：
    >
    >   ![](.\pictures\pha_3.png)
    >
    >   
    >
    >   
    >
    >   



### (3) . 四种隔离级别比较

![](pictures\four_isolate.png)

