- [锁的类型](#锁的类型)
  - [1 . MySQL 中的锁](#1--mysql-中的锁)
  - [1.1 全局锁](#11-全局锁)
    - [1.1.1 全局锁的典型使用场景：做全库逻辑备份。](#111-全局锁的典型使用场景做全库逻辑备份)
  - [1.2 表级锁](#12-表级锁)
    - [1.2.1 表锁](#121-表锁)
    - [1.2.2 元数据锁](#122-元数据锁)
  - [1.3 行锁](#13-行锁)
    - [1.3.1 行锁分类](#131-行锁分类)
    - [1.3.2 InnoDB 意向锁](#132-innodb-意向锁)
    - [1.3.3 两阶段锁协议](#133-两阶段锁协议)
    - [1.3.4 死锁和死锁检测](#134-死锁和死锁检测)

# 锁的类型

## 1 . MySQL 中的锁

数据库作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。数据库锁的设计是为了处理并发问题，是实现这些访问规则的重要的数据结构。

根据加锁的范围，`MySQL` 中的锁可以分为全局锁、表级锁和行锁。

## 1.1 全局锁

全局锁就是对整个数据库实例加锁。`MySQL` 提供了一个加全局读锁的方法 ：`Flush tables with read lock` ( `FTWRL` ) 。当需要让整个库处于只读状态时，可以使用此命令，这样可以确保其他线程不会对数据库做更新操作。

### 1.1.1 全局锁的典型使用场景：做全库逻辑备份。

在给整库加 `FTWRL` 全局锁后，整库就只处于只读状态，然后对整个库进行备份。

但让整个库处于只读状态，有以下两个弊端：

-   如果在主库上备份，则备份期间都不能执行更新操作，业务基本上就得停摆；
-   如果在从库上备份，那么从库备份期间不能执行从主库上同步过来的 `binlog` ，会导致主从延迟。

但是如果不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个备份的视图是逻辑不一致的。

`MySQL` 提供的官方逻辑备份工具是 `mysqldump` ，当 `mysqldump` 使用参数 `--single-transaction` 时，在转存储数据之前会将隔离级别设为可重复读并开启一个事务，这样可以确保视图一致性，该参数仅可在支持事务的引擎中使用，如 `InnoDB` 。

## 1.2 表级锁

`MySQL` 中的表级锁有两种：表锁和元数据锁 ( `MDL` )。

### 1.2.1 表锁

表锁就是对库中的某个表加锁。在还没出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。但是，在对于 `InnoDB` 这种支持行锁的引擎中，一般不使用 `lock tables` 命令来控制并发，因为锁住整个表的影响面较大。

### 1.2.2 元数据锁

元数据锁，又称 `MDL` 锁，全称为 `metadata lock` 。`MDL` 不需要显示使用，在访问一个表的时候会被自动加上，作用是为了保证读写的正确性。

在 `MySQL 5.5` 版本中引入了 `MDL` 锁，当对一个表做增删改查操作的时候，加 `MDL` 读锁；在对表结构做变更操作时，加 `MDL` 写锁。



## 1.3 行锁

`MySQL` 行锁是在引擎层实现的，但并不是所有的引擎支持行锁，`MyISAM` 是不支持行锁的，而 `InnoDB` 是支持行锁的，这也是引擎 `MyISAM` 被 `InnoDB` 替代的重要的原因之一。

### 1.3.1 行锁分类

行锁就是对数据表中行记录的锁。`InnoDB` 引擎实现了两种标准的行级锁：

1.  共享锁（`S Lock`），允许事务读一行数据。
2.  排他锁（`X Lock`），允许事务删除或更新一行数据。

这两种锁的兼容性如下：

|      | `X`  |   `S`    |
| :--: | :--: | :------: |
| `X`  | 互斥 |   互斥   |
| `S`  | 互斥 | **兼容** |

>   `S` 锁和 `X` 锁都是行锁，兼容是指对同一记录 (`row`) 锁的兼容性情况。

### 1.3.2 InnoDB 意向锁

`InnoDB` 引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持不同粒度上进行加锁操作，`InnoDB` 引擎支持一种额外的锁方法--意向锁。**意向锁是一种表级锁**，设计原则是为了在一个事务中揭示下一行将被请求的锁类型。意向锁分为以下两种：

-   意向共享锁（`IS Lock`）：事务想要获得一张表中某几行的共享锁；
-   意向排他锁（`IX Lock`）：事务想要获得一张表中某几行的排他锁。

因此，在记录上加共享/排他锁之前，`InnoDB` 要先在记录所在的数据表上加对应的意向锁。意向锁由引擎自己维护的，用户无法手动操作意向锁。
意向锁存在的意义是：当事务 `A` 在数据表中的某几行加锁后，另一个事务 `B` 想要在同一个表上加表级锁，那么事务 `B` 只需检查该表上的意向锁，无需检查表中是否有行锁。事务 `B` 在加锁前会受到事务 `A` 的表级别意向锁的阻塞。  

**意向锁只会与表级锁的共享或排他锁互斥，不与行级的共享或排他锁互斥。** 意向锁与表级锁的兼容关系如下：

|      |   `IS`   |   `IX`   |   `S`    |  X   |
| :--: | :------: | :------: | :------: | :--: |
| `IS` | **兼容** | **兼容** | **兼容** | 互斥 |
| `IX` | **兼容** | **兼容** |   互斥   | 互斥 |
| `S`  | **兼容** |   互斥   | **兼容** | 互斥 |
| `X`  |   互斥   |   互斥   |   互斥   | 互斥 |

从以上表格可得两个结论：

1.  意向锁之间是互相兼容的；
2.  意向锁与表级的排他/共享锁是互斥的。



### 1.3.3 两阶段锁协议

在 `InnoDB` 事务中，行锁在需要的时候才加上的，但并不是不需要的时候就立即释放，而是等事务结束后才释放，这就是两阶段锁协议。

### 1.3.4 死锁和死锁检测

死锁：和`OS`中死锁的原理类似。在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待其他线程释放资源时，就会导致这几个线程进入无限循环等待的状态，这就是死锁。出现死锁后，可以通过命令 `show engine innodb status\G` 的输出内容查看事务的持有锁的情况和死锁记录。

![](./pictures/lock.png)

>   如上图所示，事务 `A` 在等待事务 `B` 释放 `id = 2` 的行锁，而事务 `B` 在等待事务 `A` 释放 `id = 1` 的行锁。事务 `A` 和 事务 `B` 在互相等待对方的资源释放，无法继续向前推进，这样就进入了死锁。 

死锁检测：当出现死锁时，有两种策略进行检测。

1.  超时

    当两个事务互相等待时，如果一个等待时间超过设置的某个阀值时，其中一个事务进行回滚，另一个等待的事务就能继续执行。在 `InnoDB` 中，通过设置参数**`innodb_lock_wait_timeout`** 来设置超时时间，默认是 `50s`。在 `MySQL` 中可以通过命令 `show variables like '%innodb_lock_wait_timeout%'` 查看。

    虽然超时机制较简单，但其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据 `FIFO` 的顺序选择进行回滚对象。如果超时的事务所占的权重较大，这时对其进行回滚，就不合适了。

2.  主动死锁检测

    `MySQL` 中参数 `innodb_deadlock_detect` 默认是 `on`，表示开启主动死锁检测。可以通过命令 `show variables like '%innodb_deadlock_detect%'` 查看。

    `InnoDB` 引擎通过 `wait-for graph` ( 等待图 ) 方式来检测死锁。

    `wait-for graph` 要求数据库存放以下两种信息：

    -   锁的信息链表
    -   事务等待链表

    通过上图链表可以构造出一个图，如果图中存在回路，则代表存在死锁。

    在 `wait-for graph` 中，图中每个节点代表事务，图中的有向边 ( `T1 ---> T2` ) 表示事务 `T1` 等待事务 `T2` 释放资源。

    在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说 `InnoDB` 存储引擎会选择回滚 `undo` 量最小的事务。

