[toc]

# 锁的类型

-------------------------------

## 1 . MySQL 中的锁

数据库作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。数据库锁的设计是为了处理并发问题，是实现这些访问规则的重要的数据结构。

根据加锁的范围，`MySQL` 中的锁可以分为全局锁、表级锁和行锁。

## 1.1 全局锁

--------------------

全局锁就是对整个数据库实例加锁。`MySQL` 提供了一个加全局读锁的方法 ：`Flush tables with read lock` ( FTWRL ) 。当需要让整个库处于只读状态时，可以使用此命令，这样可以确保其他线程不会对数据库做更新操作。

### 1.1.1 全局锁的典型使用场景：做全库逻辑备份。

在给整库加 FTWRL 全局锁后，整库就只处于只读状态，然后对整个库进行备份。

但让整个库处于只读状态，有以下两个弊端：

-   如果在主库上备份，则备份期间都不能执行更新操作，业务基本上就得停摆；
-   如果在从库上备份，那么从库备份期间不能执行从主库上同步过来的 `binlog` ，会导致主从延迟。

但是如果不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个备份的视图是逻辑不一致的。

`MySQL` 提供的官方逻辑备份工具是 `mysqldump` ，当 `mysqldump` 使用参数 `--single-transaction` 时，在转存储数据之前会将隔离级别设为可重复读并开启一个事务，这样可以确保视图一致性，该参数仅可在支持事务的引擎中使用，如 `InnoDB` 。

## 1.2 表级锁

-------------------------------------

`MySQL` 中的表级锁有两种：表锁和元数据锁 ( `MDL` )。

### 1.2.1 表锁

表锁就是对库中的某个表加锁。在还没出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。但是，在对于 `InnoDB` 这种支持行锁的引擎中，一般不使用 `lock tables` 命令来控制并发，因为锁住整个表的影响面较大。

### 1.2.2 元数据锁

元数据锁，又称 `MDL` 锁，全称为 `metadata lock` 。`MDL` 不需要显示使用，在访问一个表的时候会被自动加上，作用是为了保证读写的正确性。

在 `MySQL 5.5` 版本中引入了 `MDL` 锁，当对一个表做增删改查操作的时候，加 `MDL` 读锁；在对表结构做变更操作时，加 `MDL` 写锁。



## 1.3 行锁

-------------------------------

`MySQL` 行锁是在引擎层实现的，但并不是所有的引擎支持行锁，`MyISAM` 是不支持行锁的，而 `InnoDB` 是支持行锁的，这也是引擎 `MyISAM` 被 `InnoDB` 替代的重要的原因之一。

行锁就是对数据表中行记录的锁。

### a. 两阶段锁协议

在 `InnoDB` 事务中，行锁在需要的时候才加上的，但并不是不需要的时候就立即释放，而是等事务结束后才释放，这就是两阶段锁协议。

### b. 死锁和死锁检测

死锁：和`OS`中死锁的原理类似。在并发系统中不同线程出现循环资源依赖，涉及的线程都在等待其他线程释放资源时，就会导致这几个线程进入无限循环等待的状态，这就是死锁。

![](.\pictures\lock.png)

>   如上图所示，事务 `A` 在等待事务 `B` 释放 `id = 2` 的行锁，而事务 `B` 在等待事务 `A` 释放 `id = 1` 的行锁。事务 `A` 和 事务 `B` 在互相等待对方的资源释放，无法继续向前推进，这样就进入了死锁。 

死锁检测：当出现死锁时，有两种策略进行检测。

1.  超时

    当两个事务互相等待时，如果一个等待时间超过设置的某个阀值时，其中一个事务进行回滚，另一个等待的事务就能继续执行。在 `InnoDB` 中，通过设置参数**`innodb_lock_wait_timeout`** 来设置超时时间，默认是 `50s`。在 `MySQL` 中可以通过命令 `show variables like '%innodb_lock_wait_timeout%'` 查看。

    虽然超时机制较简单，但其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据 `FIFO` 的顺序选择进行回滚对象。如果超时的事务所占的权重较大，这时对其进行回滚，就不合适了。

2.  主动死锁检测

    `MySQL` 中参数 `innodb_deadlock_detect` 默认是 `on`，表示开启主动死锁检测。可以通过命令 `show variables like '%innodb_deadlock_detect%'` 查看。

    `InnoDB` 引擎通过 `wait-for graph` ( 等待图 ) 方式来检测死锁。

    `wait-for graph` 要求数据库存放以下两种信息：

    -   锁的信息链表
    -   事务等待链表

    通过上图链表可以构造出一个图，如果图中存在回路，则代表存在死锁。

    在 `wait-for graph` 中，图中每个节点代表事务，图中的有向边 ( T1 ---> T2 ) 表示事务 `T1` 等待事务 `T2` 释放资源。

    在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁，通常来说 `InnoDB` 存储引擎会选择回滚 `undo` 量最小的事务。

    

     

