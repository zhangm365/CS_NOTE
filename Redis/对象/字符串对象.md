- [字符串对象的编码](#字符串对象的编码)
- [1. `int` 编码](#1-int-编码)
- [2. `raw` 编码](#2-raw-编码)
- [3. `embstr` 编码](#3-embstr-编码)
  - [3.1 `embstr` 优点](#31-embstr-优点)
# 字符串对象的编码

字符串的编码可以是 `int`，`raw`，`embstr`三种。

# 1. `int` 编码

如果一个字符串对像保存的是整数值，并且可用 `long` 类型表示时，那么字符串对象会将整数值保存在`redisObject`中的`ptr`属性。

在文件 `object.c` 中源码实现如下：

```c
if (value >= LONG_MIN && value <= LONG_MAX) {
    o = createObject(OBJ_STRING, NULL);
    o->encoding = OBJ_ENCODING_INT;
    o->ptr = (void*)((long)value);
} else {
    o = createObject(OBJ_STRING,sdsfromlonglong(value));
}
```

如下图是存储结构：

![](../pics/str_int.png)

# 2. `raw` 编码

这种编码方式适合保存较长的字符串值。

当字符串对象保存的是一个字符串值，并且这个字符串值的长度 **大于`44` 字节** 时，那么`redis`就用`raw`个字符串值。

这种编码方式是单独分配一块内存空间来保存对象的字符串值，即采用`raw`编码的字符串对象要进行 **两次内存分配**。

首先调用函数`createObject`分配一次内存空间，又调用了`sdsnewlen`函数。函数`sdsnewlen`为对应的`sds`字符串分配空间。所以，`createRawStringObject`进行了两次内存分配。源码如下：

```c
robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}
```

存储结构为：

![](../pics/str_raw.png)

# 3. `embstr` 编码

这种编码方式适合保存较短的字符串值。

当字符串对象保存的是一个字符串值，并且这个字符串值的长度 **小于等于`44` 字节** 时，那么`redis`就用`embstr`编码保存这个字符串值。

> 为什么是 44 个字节，因为`redis` 一次为`embstr`编码的字符串对象分配 64 个字节，64 - 16 - 4 = 44。（16是`redisObject`的大小，`sds` 头数据是 3 个字节，再减去一个 `\0`）

`embstr`编码表示嵌入字符串，即在对象本身的同一块内存空间中存储该对象的字符串值，如下是源码：

```c
robj *createEmbeddedStringObject(const char *ptr, size_t len) {
    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);    // 一次分配一块连续的内存
    struct sdshdr8 *sh = (void*)(o+1);

    o->type = OBJ_STRING;
    o->encoding = OBJ_ENCODING_EMBSTR;
    o->ptr = sh+1;    // 指向 sds 字符串首地址
    o->refcount = 1;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }

    sh->len = len;
    sh->alloc = len;
    sh->flags = SDS_TYPE_8;
    if (ptr == SDS_NOINIT)
        sh->buf[len] = '\0';
    else if (ptr) {
        memcpy(sh->buf,ptr,len);
        sh->buf[len] = '\0';
    } else {
        memset(sh->buf,0,len+1);
    }
    return o;
}
```

![](../pics/str_emb.png)

## 3.1 `embstr` 优点

1. 只需要一次内存分配，比`raw`编码减少了一次内存的分配与释放次数；
2. 字符串值保存在一块连续的内存空间中，因此它比`raw`编码的对象可以更好地利用缓存带来的优势。

另外，`embstr` 编码的字符串是只读的，不可以更改。当对其执行修改命令时，会转变成`raw`格式。

```shell
127.0.0.1:6379> set msg hello
OK
127.0.0.1:6379> object encoding msg
"embstr"
127.0.0.1:6379> append msg world
(integer) 10
127.0.0.1:6379> object encoding msg
"raw"

```

# 4. 哈希命令

`SET`、`GET`等。
