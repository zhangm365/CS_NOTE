# 有序集合

有序集合的编码可以是`ziplist`或`skiplist`。

# 1. `ziplist`编码

`ziplist`编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个元素保存元素的分值。**压缩列表内的集合元素按分值从小到大进行排序**。

如以下`price`键的值对象使用的`ziplist`编码：

```shell
127.0.0.1:6379> zadd price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
127.0.0.1:6379> type price
zset
127.0.0.1:6379> object encoding price
"ziplist"

```

如下图所示：

![](../pics/zset_zl.png)

有序集合元素在压缩列表中按分值从小到大排序：

![](../pics/zset_zl_2.png)

# 2. `skiplist`编码

`skiplist`编码的有序集合对象使用`zset`数据结构作为底层实现，一个`zset`同时包括一个字典和一个跳表：

```c
typedef struct zset {
    dict *dict;    // 字典
    zskiplist *zsl;    // 跳跃表
} zset;
```

`zset`结构中的`zsl`跳表按分值从小到大保存了所有集合元素，每个跳表节点都保存了一个集合元素：跳表节点的`ele`属性保存了元素的成员，跳表节点的`score`属性则保存了元素的分值。通过跳表，有序集合可以进行范围型操作，比如`ZRANK`、`ZRANGE`等命令就是基于跳表`API`实现的。

而`zset`结构中的`dict`字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值保存了元素的分值。通过字典，有序集合可以在`O(1)`时间复杂度内查找给定成员的分值，`ZSCORE`命令就是基于这个特性实现的。

## 2.1 为什么有序集合同时使用字典和跳表？

有序集合可以使用字典或跳表的其中一种数据结构来实现，但性能上相比同时使用字典和跳表有所下降。原因如下：

1. 当只有字典实现有序集合时，可以保证在常数时间复杂度内查找成员的分值，但因为字典以 **无序的方式** 来保存集合元素，因此在执行范围型操作时，程序需要对字典中的元素进行排序，排序的时间复杂度至少是`O(NlogN)`。

2. 而如果只用跳表实现有序集合时，可以执行范围型操作，但需要`O(logN)`的复杂度来获取给定成员的分值。

综上，为了让有序集合尽可能快的执行元素查找和范围型操作，同时使用了字典和跳表的数据结构来实现有序集合。但两种数据结构会通过指针来共享相同元素的成员和分值，不会额外浪费内存。

## 2.2 结构

使用`skiplist`编码的有序集合对象结构如下：

![](../pics/zset_zl_3.png)

# 3. 编码转换

对于使用`ziplist`编码的有序集合对象，需要满足以下两个条件：

1. 有序集合中保存的元素个数小于`128`；
2. 有序集合中的所有元素成员的长度都小于`64`字节；

在`redis.conf`由下面两个参数配置：

```c
zset-max-ziplist-entries 128    // 压缩列表中的最大节点数
zset-max-ziplist-value 64    // 压缩列表中每个节点的最大长度
```

当存储的元素不满足上面的任意条件时，则有序集合对象将使用`skiplist`编码。

# 4. 命令

`ZADD`、`ZCARD`等。