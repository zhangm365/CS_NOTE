# 惰性删除 `lazy-free` 原理

## 1. 配置项

在 `redis server`开始运行时，可以配置惰性删除的相关选项。

`lazyfree-lazy-eviction` ：表示缓存淘汰时的数据删除选项，它定义在 `server.h` 中结构体`redisServer`中，默认是 `no`。

当要开启惰性删除时，将 `lazyfree-lazy-eviction` 置为 `yes`。

## 2. 被淘汰数据的删除过程

函数 `freeMemoryIfNeeded` 负责执行数据淘汰的过程，数据的删除过程主要分为两步。

```c
int freeMemoryIfNeeded(void) {
	...
    if (bestkey) {
            db = server.db+bestdbid;
            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));
            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);
            /* We compute the amount of memory freed by db*Delete() alone.
             * It is possible that actually the memory needed to propagate
             * the DEL in AOF and replication link is greater than the one
             * we are freeing removing the key, but we can't account for
             * that otherwise we would never exit the loop.
             *
             * Same for CSC invalidation messages generated by signalModifiedKey.
             *
             * AOF and Output buffer memory will be freed eventually so
             * we only care about memory used by the key space. */
            delta = (long long) zmalloc_used_memory();
            latencyStartMonitor(eviction_latency);
            if (server.lazyfree_lazy_eviction)
                dbAsyncDelete(db,keyobj);
            else
                dbSyncDelete(db,keyobj);
}
```



1. 调用 `propagateExpire` 函数，该函数根据全局变量 `server.lazyfree-lazy-eviction` 来决定删除操作具体执行哪个命令。

   ```c
   void propagateExpire(redisDb *db, robj *key, int lazy) {
       robj *argv[2];	// struct redisObject 
   
       argv[0] = lazy ? shared.unlink : shared.del;	// 结构体数组第一个元素存放执行的删除命令，如果开启惰性删除，则执行unlink
       argv[1] = key;	// 第二个存放要删除的key对象
       incrRefCount(argv[0]);
       incrRefCount(argv[1]);
   
       if (server.aof_state != AOF_OFF)	// 是否开启了 AOF 日志，开启后则需要把删除命令写入 AOF 日志
           feedAppendOnlyFile(server.delCommand,db->id,argv,2);
       replicationFeedSlaves(server.slaves,db->id,argv,2);		// 删除操作同步给从节点，保证主从数据一致性
   
       decrRefCount(argv[0]);
       decrRefCount(argv[1]);
   }
   ```

   如果开启了惰性删除选项，则执行 `unlink` 命令，否认执行 `del` 命令。

