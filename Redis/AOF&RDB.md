- [`AOF & RDB`](#aof--rdb)
- [1. `AOF` 日志](#1-aof-日志)
  - [1.1 `AOF`持久化实现](#11-aof持久化实现)
    - [1.1.1 命令追加](#111-命令追加)
    - [1.1.2 `AOF`文件的写入与同步](#112-aof文件的写入与同步)
  - [1.2 `AOF`文件的载入和数据还原](#12-aof文件的载入和数据还原)
  - [1.3 `AOF`重写](#13-aof重写)
    - [1.3.1 重写原理](#131-重写原理)
    - [1.3.2 实现方式](#132-实现方式)
- [2. `RDB` 快照](#2-rdb-快照)
  - [2.1 `RDB`文件的创建](#21-rdb文件的创建)
  - [2.2 `RDB`文件结构](#22-rdb文件结构)

# `AOF & RDB`

`AOF` 日志和 `RDB` 快照是 `redis` 中数据持久化的两种方式，保证了 `Redis` 数据库中的数据可靠性。

因为`AOF`文件的更新频率通常比`RDB`文件更新频率高，所以：

1. 如果服务器开始了`AOF`持久化功能，那么服务器会优先使用`AOF`文件来还原数据库状态；
2. 只有在`AOF`持久化功能关闭时，服务器才会使用`RDB`文件来还原数据库状态。

# 1. `AOF` 日志

`AOF` 日志以 "命令+键值对" 的形式来追加记录每个键值对的 **写操作**。主线程在处理客户端的读写需求时，写操作会被主线程正常写入到 `AOF` 日志文件。

## 1.1 `AOF`持久化实现

`AOF`持久化功能的实现可以分为：命令追加、文件写入和文件同步三个步骤。

### 1.1.1 命令追加

当`AOF`持久化功能打开后，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的`aof_buf`缓存区：

```c
struct redisServer {
    ...    
    // AOF缓冲区    
    sds aof_buf;    
    ...
};
```

如以下示例：

```shell
127.0.0.1:6379> SET KEY VALUE
OK
# 那么服务器在执行这个SET命令之后，会将以下协议内容追加到 aof_buf 缓冲区的末尾：
*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n
# 如果客户端向服务器发送以下命令：
127.0.0.1:6379> RPUSH NUMBERS ONE TWO THREE
(integer) 3
# 那么服务器在执行这个RPUSH命令之后，会将以下协议内容追加到 aof_buf 缓冲区的末尾：
*5\r\n$5\r\nRPUSH\r\n$7\r\nNUMBERS\r\n$3\r\nONE\r\n$3\r\nTWO\r\n$5\r\nTHREE\r\n

```

### 1.1.2 `AOF`文件的写入与同步

`Redis`服务器进程是一个事件循环程序，循环中的文件事件负责接收客户端的命令请求。当服务器在处理文件事件的写命令时，就会将这些写命令追加到`aof_buf`缓存区。

在服务器每次结束一个事件循环之前，它都会调用`flushAppendOnlyFile`函数，考虑是否将`aof_buf`缓存区中的内容写入和保存到`AOF`文件里。

服务器配置`appendfsync`选项的值决定`AOF`持久化功能的效率和安全性。它有以下三个选项：

1. `always`：服务器每个事件循环都将`aof_buf`缓存区的内容写入`AOF`文件，并且立即同步`AOF`文件到磁盘；
2. `everysec`：`...`，并且每隔`1`秒就要在子进程中对`AOF`文件进行一次同步；
3. `no`：`...`，对于何时对`AOF`文件进行同步落盘，则由操作系统控制。

## 1.2 `AOF`文件的载入和数据还原

因为`AOF`文件中包含了重建数据库状态所需的所有写命令，所以只要服务器载入`AOF`文件并重新执行一遍`AOF`文件中的内容，就可以恢复服务器关闭之前的数据库状态。

`Redis`读取`AOF`文件并还原数据库状态的流程如下：

1. 服务器创建一个不带网路连接的伪客户端；
2. 从`AOF`文件中分析并读取的一条写命令；
3. 使用伪客户端执行被读出的写命令；
4. 重复第`2`和`3`步，直到`AOF`文件中的命令都被处理完毕。

如以下的`AOF`文件所保存的内容：

```shell
*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n    # select 0, 选择0号数据库
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n    # SET msg hello
*5\r\n$4\r\nSADD\r\n$6\r\nfruits\r\n$5\r\napple\r\n$6\r\nbanana\r\n$6\r\ncherry\r\n    # SADD fruits apple banana cherry
*5\r\n$5\r\nRPUSH\r\n$7\r\nnumbers\r\n$3\r\n128\r\n$3\r\n256\r\n$3\r\n512\r\    # RPUSH numbers 128 256 512
```



## 1.3 `AOF`重写

当 `Redis server` 的写请求很多，`AOF` 会记录接收到的所有写操作，会导致`AOF`日志文件也会越来越大。

为了避免 `AOF` 日志文件过大，`Redis` 会对 `AOF` 文件进行重写，即针对当前数据库每个键值对的最新内容，记录它的插入操作，不再记录它的历史写操作了，这样重写后的 `AOF` 日志会变小。

### 1.3.1 重写原理

`Redis`服务器将生成新的`AOF`文件来代替旧的`AOF`文件，服务器首先读取数据库中键的最新状态，然后用一条命令记录键值对，代替之前记录这个键值对的多条命令，从而实现对`AOF`重写的功能。

### 1.3.2 实现方式

`AOF` 重写日志是通过创建 **子进程** 来重写数据的，这样可以避免阻塞主线程，减少对 `Redis` 整体性能的影响。

在主进程执行写操作时，`AOF` 重写子进程会尽可能执行从主线程发来的写命令。父子进程间通信是通过 `pipe` 管道机制来通信的。

建立的管道有 `3` 个：操作命令发送管道和 `2` 个`ACK` 信息发送管道。

# 2. `RDB` 快照

`RDB` 快照是记录 `Redis` 服务器的某个时刻的数据库状态，只记录键值对数据本身，是以 **二进制形式** 存放的。

## 2.1 `RDB`文件的创建

有两个`Redis`命令可以用来创建`RDB`文件，一个是`SAVE`，另一个是`BGSAVE`。

1. `SAVE`命令会阻塞`Redis`服务器主进程，直到`RDB`文件创建完成，在服务器主进程阻塞期间，服务器不能处理其他请求。
2. `BGSAVE`命令会派生出一个子进程，由子进程来负责创建`RDB`文件，服务器主进程可以继续处理命令请求。

```shell
127.0.0.1:6379> save
OK
127.0.0.1:6379> bgsave
Background saving started    # 后台创建子进程来生成 RDB 文件
127.0.0.1:6379>
```

创建`RDB`文件由`rdb.c/rdbSave`函数实现，执行命令后函数调用关系如下：

![](./pics/rdb_1.png)

## 2.2 `RDB`文件结构

`RDB`文件结构如下：

![](./pics/rdb_2.png)

`REDIS`：表示这是个`RDB`文件，占`5`个字节；

`db_version`：`RDB`文件的版本号，占`4`个字节；

`databases`：包含`0`个或任意多个数据库，以及各个数据库中的键值对数据；

`EOF`：表示`RDB`文件的结束，占`1`个字节；

`check_sum`：校验和，`8`字节长的无符号整数。



