
# 1. 数据库中添加自定义系统表

在数据库中添加自定义的系统表，操作步骤如下：

## 1.1. 新增系统表头文件

在目录 `.../src/postgres/src/include/catalog/` 新增定义的头文件
例如新增名为 `pg_bm_encryption` 系统表的头文件：

> 文件格式严格按照原有头文件格式的副本进行书写，可以避免不必要的错误。

```c
#ifndef PG_BM_ENCRYPTION_H
#define PG_BM_ENCRYPTION_H

#include "catalog/genbki.h"
// It has been GENERATED by src/backend/catalog/genbki.pl
#include "catalog/pg_bm_encryption_d.h"

CATALOG(pg_bm_encryption,3434,EncryptionRelationId) BKI_SCHEMA_MACRO
{
    Oid    objoid;    /* OID of object itself */
    Oid    classoid;    /* OID of table containing object */
    int32    objsubid;    /* column number, or 0 if not used */
} FormData_pg_encryption;

/* ----------------
 *    Form_pg_bm_encryption corresponds to a pointer to a tuple with
 *    the format of pg_bm_encryption relation.
 * ----------------
 */
typedef FormData_pg_bm_encryption * Form_pg_bm_encryption;

// index for the column on global_key_name
DECLARE_UNIQUE_INDEX(pg_bm_client_global_keys_oid_index, 8061, on pg_bm_encryption using btree(global_key_name name_ops));
#define BmClientGlobalKeysOidIndexId 8061

#endif    /* PG_BM_ENCRYPTION_H */
```

### 1.1.1. 编写规则

#### 1.1.1.1. 分配 `OID`

运行 `src/include/catalog/` 目录中的 `unused_oids` 可执行程序，确定系统中还未使用的 `OID`。然后在 `CATALOG` 中为当前表分配一个唯一的 `OID`。

例如：3434 是为表 `pg_bm_encryption` 分配的 `OID`，8061 是为索引分配的 `OID`。

#### 1.1.1.2. 定义索引约束

根据 `src/postgres/src/include/catalog/indexing.h` 中的 `DECLARE_UNIQUE_INDEX` 定义：

`#define DECLARE_UNIQUE_INDEX(name,oid,decl)`

前两个字段是索引名字和 `OID`，剩余参数是类似于索引创建 `create index` 的 `SQL` 命令。
标准创建索引的语法如下：
`CREATE INDEX name ON table (column_name opclass [sort options] [, ...]);`

然后在源文件中定义表的索引，在 [PostgreSQL 14 版本](https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=bdc4edbea6fc847f806e1e7118d730e159512bfc) 中将索引约束移到源文件中定义：

```c
DECLARE_UNIQUE_INDEX(pg_bm_client_global_keys_oid_index, 8061, on pg_bm_encryption using btree(global_key_name name_ops));
#define BmClientGlobalKeysOidIndexId 8061
```

> [operator class](https://www.postgresql.org/docs/current/indexes-opclass.html):
> The operator class identifies the operators to be used by the index for that column. For example, a B-tree index on the type int4 would use the int4_ops class; this operator class includes comparison functions for values of type int4. In practice the default operator class for the column's data type is usually sufficient. The main reason for having operator classes is that for some data types, there could be more than one meaningful index behavior.

#### 1.1.1.3. 潜在错误分析

这个文件是非常重要的，目前编程过程遇到以下两类错误：

1. 编译器无法识别 `CATALOG` 结构中的 变量类型 。

   这将导致编译 `PostgreSQL` 会报错。具体报错原因可以根据 编译 `PostgreSQL` 的输出定位。

2. 提示 "`pg_bm_encryption_d.h`文件不存在" 错误。

那么可能是源文件 `pg_bm_encryption.h` 格式错误。

## 1.2. 修改 `Makefile` 文件

修改 `.../src/postgres/src/backend/catalog/Makefile` 文件
根据 1.1 步骤中定义的头文件，在 `Makefile` 文件中 `CATALOG_HEADERS` 标签末尾添加头文件名 `pg_bm_encryption.h`。

## 1.3. 编译

### 1.3.1. 仅编译 `PostgreSQL`

在添加或修改系统表后，可以优先仅编译 `PostgreSQL` 进行测试：

```shell
# 具体可通过 help 命令查看
./bm_build --rebuild-postgres --sj -j16 2>&1 | tee postgres_build.log

# 如果新添加的头文件中 变量类型 有问题，则输出错误如下（无法加载 .so 链接库）：
[4/4] cd /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/src... /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja --step make
FAILED: src/postgres/CMakeFiles/postgres postgres/lib/libpq.so postgres/lib/libbm_pgbackend.so /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/src/postgres/CMakeFiles/postgres /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/postgres/lib/libpq.so /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/postgres/lib/libbm_pgbackend.so
```

但是 `PostgreSQL` 编译通过不代表整编通过。

### 1.3.2. 整编

全部编译整个数据库。

1. 编译前需要清空 build 目录。

   编译添加 --clean-all 参数
   `./bm_build --clean-all --sj 2>&1 | tee build.log`

2. 数据库编译过程中会生成一份快照数据文件：`exported_tablet_metadata_changes`。

   它位于 `/home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/share/initial_sys_catalog_snapshot/` 目录下。
   如下是编译过程输出的信息显示该文件所在路径：

   ```shell
   2023-07-07 17:30:58,028 [gen_initial_sys_catalog_snapshot.py:55 INFO] Starting creating initial system catalog snapshot data
   2023-07-07 17:30:58,028 [gen_initial_sys_catalog_snapshot.py:56 INFO] Logging to: /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/create_initial_sys_catalog_snapshot.err
   2023-07-07 17:34:23,070 [gen_initial_sys_catalog_snapshot.py:76 INFO] Initial system catalog snapshot data creation took 205 sec. Wrote data to: /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/share/initial_sys_catalog_snapshot
   ```

   此外，我们可以单独运行以下命令来测试新增的系统表是否加载成功：
   运行之前首先要删除 `/home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/share/initial_sys_catalog_snapshot/` 目录

   ```shell
   /home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/tests-pgwrapper/create_initial_sys_catalog_snapshot --initial_sys_catalog_snapshot_dest_path=/home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/share/initial_sys_catalog_snapshot --gtest_output=xml:/home/bigmath/code/bigmath-db/build/debug-clang15-dynamic-ninja/bm-test-logs/tests-pgwrapper__create_initial_sys_catalog_snapshot/CreateInitialSysCatalogSnapshotTest_CreateInitialSysCatalogSnapshot.xml --gtest_filter=CreateInitialSysCatalogSnapshotTest.CreateInitialSysCatalogSnapshot 2>&1 | tee catalog_snapshot.log
   ```

   在生成的日志中，根据表名搜索新增的系统表是否成功。

3. 代码分析

   ```c++
   // src/bm/master/master_main.cc
   static int MasterMain(int argc, char** argv) {
      // 在 master 启动服务时，函数 SetDefaultInitialSysCatalogSnapshotFlags 会设置 CatalogSnapshot 路径参数
      SetDefaultInitialSysCatalogSnapshotFlags();
   }
   ```

## 1.4. 查看系统表

编译成功并启动数据库服务后，可以查看系统表信息：

1. 查看系统表是否创建成功

   ```sql
   select tablename from pg_tables order by tablename;
   ```

2. 系统表的信息

   ```sql
   \d+ tablename;

   Table "pg_catalog.pg_bm_encrypted_columns"
          Column         |            Type             | Collation | Nullable | Default | Storage | Stats target | Description 
   ------------------------+-----------------------------+-----------+----------+---------+---------+--------------+-------------
   ```

# 2. 元数据管理代码

数据库中是如何进行写 `Catalog Snapshot` 的？
根据 `exported_tablet_metadata_changes` 关键字，查看字符串定义：
`kSysCatalogSnapshotTabletMetadataChangesFile`。
这个字符串在如下函数中定义使用：

## 2.1. `WriteSnapshot`

```c++
// .../src/bm/master/sys_catalog_initialization.cc
/*
 * bm::master::InitialSysCatalogSnapshotWriter::WriteSnapshot(bm::tablet::Tablet*, 
 *            std::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)
 *
 */
class InitialSysCatalogSnapshotWriter {
  public:
    Status WriteSnapshot(
      tablet::Tablet* sys_catalog_tablet,
      const std::string& dest_path);
};

Status InitialSysCatalogSnapshotWriter::WriteSnapshot(
    tablet::Tablet* sys_catalog_tablet,
    const std::string& dest_path) {
  ...
  // 快照文件路径
  const string metadata_changes_file = JoinPathSegments(
      dest_path,
      kSysCatalogSnapshotTabletMetadataChangesFile);

  RETURN_NOT_OK(WritePBContainerToPath(
      Env::Default(),
      metadata_changes_file,
      exported_tablet_metadata_changes,
      pb_util::CreateMode::NO_OVERWRITE,
      pb_util::SyncMode::NO_SYNC));
}
```

## 2.2. `WritePBContainerToPath`

```c++
// .../src/bm/util/pb_util.h
namespace pb_util {
  /* 
   * Serialize a "containerized" protobuf to the given path.
   * @path: 文件路径
   * If create == NO_OVERWRITE and 'path' already exists, the function will fail.
   * If create == OVERWRITE and 'path' already exists, then it is atomically replaced. If there is a
   * system crash during the operation, it is guaranteed that an intact copy of either the old or new
   * version of the file will continue to exist.
   * If sync == SYNC, the newly created file will be fsynced before returning.
   */
  Status WritePBContainerToPath(Env* env, const std::string& path,
                                const google::protobuf::Message& msg,
                                CreateMode create,
                                SyncMode sync);
}  // end namespace pb_util

```

# 3. 表数据知识点

## 3.1. `Object Identifier Type(OID)`

`OID` 是 `Postgres` 数据库内部作为区分每个表的主键。

```sql
-- 查看某个表的 oid
SELECT attrelid FROM pg_attribute WHERE attrelid = 'tablename'::regclass limit 1;

-- 查看 schema 中 pg_catalog （系统表模式）中是否存在某个表
SELECT EXISTS (
   SELECT FROM pg_tables
   WHERE  schemaname = 'pg_catalog'
   AND    tablename  = 'tablename'
   );

-- 查看某个 schema 的 oid
SELECT to_regnamespace('public')::oid;
```
