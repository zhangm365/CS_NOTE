
# vacuuming

`PostgreSQL` 需要周期性维护，即称为 `vacuuming`（抽真空）。

对于许多安装性程序而言，让 `autovacuum` （自动抽真空）作为后台守护进程执行 `vacuuming` （清理工作）就已足够。

## 1. `vacuuming` 基本知识

在 `Postgres` 中，`VACUUM` 命令必须定期处理每个表，原因如下：

1. 恢复或重用被更新或删除行所占用的磁盘空间；

    这可以有效防止表的膨胀和提升磁盘利用空间。

2. 更新用于 `Postgres` 查询计划器的数据统计信息；

    这对查询计划的生成和优化查询执行策略至关重要，从而提高数据的查询性能。

3. 更新可见性图谱，从而加速仅索引扫描（index-only scans）的速度；

    仅索引扫描指的是，`Postgres` 支持仅通过索引数据回答查询，不需要访问 `Heap`（存储表数据的主要区域）。

4. 防止因事务或多事务 ID 环绕导致丢失非常旧的数据。

   及时释放事务 ID，避免事务 ID 用尽的情况。

有两种关于 `VACUUM` 的使用方法：标准 `VACUUM` 和 `VACUUM FULL` 命令。

`VACUUM FULL` 可以回收更多的磁盘空间但运行较慢，当 `VACUUM FULL` 执行时，它会在表级上请求 `ACCESS EXCLUSIVE` 锁，因此无法同时进行表操作。而标准 `VACUUM` 命令可以和生产数据库的操作并行运行（例如，`SELECT`、`INSERT`、`UPDATE`、`DELETE` 命令可以正常执行，但是 `ALTER TABLE` 在 `vacuuming` 过程中无法使用）。

我们应该优先使用标准 `VACUUM` 命令，避免使用 `VACUUM FULL` 命令。
然而，`VACUUM` 会产生大量的 I/O 操作，会影响其他活动会话的性能下降，可以通过调整配置参数来减少后台 `vacuuming` 对性能的影响。

### 1.1. 释放磁盘空间

在 `Postgres` 中，对一条记录进行 `UPDATE` 和 `DELETE` 操作并不会立即移除该记录的旧版本，因为要想获得 `MVCC` 的好处，就必须采取这种方法：当记录版本仍有可能被其他事务看到时，就不能删除它。
但是最终，一个过期或删除的记录对任何事务而言不再需要，为了避免它无限制地占用磁盘空间，可以通过运行 `VACUUM` 来实现这个功能。

`autovacuum` 守护进程通常足以完成这项工作。

### 1.2. 更新计划器统计信息

`PostgreSQL` 查询计划器根据表内容的统计信息来生成好的查询计划，这些统计信息由 `ANALYZE` 命令收集。因此拥有相当正确的统计信息非常重要，否则错误的选择计划可能会降低数据库的性能。

如果启动了 `autovacuum` 守护进程，只要表的内容发生较大变化后，会自动发出 `ANALYZE` 命令。

### 1.3. 更新可见图谱

`VACUUM` 为每个表维持一个可见图谱，来跟踪哪些页面只包括已知对所有活动事务可见的元组。这样做包括两个目的，首先 `VACUUM` 本身可以在下次运行时跳过这些页面，因为这无须清理。

其次，它允许 `Postgres` 仅使用索引回答某些查询，不需要访问底层数据表。

### 1.4. 防止事务 ID 环绕故障

`PostgreSQL` 中 `MVCC` 事务语义依赖于可以比较事务 ID (XID) 数字：一个插入行 XID 大于当前事务的 XID 是“未来的”，对当前事务是不可见的。

因为事务 ID 的大小是有限的（32 bits），如果集群中长时间运行（超过 40 亿个事务），那么将会导致事务 ID 环绕问题：XID 计数器将重新从 0 开始计数，过去的事务突然变成了未来的事务，这意味着它们的输出不再可见。简言之，这是灾难性的数据丢失。（实际上，数据还在，但是无法获取，这种情况不容乐观。）为了避免这种情况，有必要至少每完成 20 亿次事务，对每个数据库中的每个数据表上进行一次清理。

周期运行 `vacuuming` 可以解决这个问题的原因在于 `VACUUM` 将记录标记为冻结的，意味着它们是由很久之前已提交事务插入的，以至于所有当前和将来的事务都能看到插入事务的影响。

为了解决这个问题，在 `PostgreSQL` 中保留了一个特殊的 XID，`FrozenTransactionId`，它不遵循普通的 XID 比较规则，而总是被认为比每个普通 XID 更旧的版本。
