- [数据库表的空间回收](#数据库表的空间回收)
  - [1. InnoDB 表的结构](#1-innodb-表的结构)
    - [1.1 表数据](#11-表数据)
  - [2. 数据删除流程](#2-数据删除流程)
    - [2.1 记录的复用和数据页的复用的区别](#21-记录的复用和数据页的复用的区别)
  - [3. 数据的插入](#3-数据的插入)
  - [4. 重建表](#4-重建表)
    - [4.1 场景模拟：现在存在一个表 `A`，需要做收缩空间，为了把表中的空洞去掉，可以怎么做？](#41-场景模拟现在存在一个表-a需要做收缩空间为了把表中的空洞去掉可以怎么做)
    - [4.2 Online DDL](#42-online-ddl)

# 数据库表的空间回收

## 1. InnoDB 表的结构

`MySQL` 中 `InnoDB` 引擎中的表包含两个部分：表结构定义和表中数据。在 `MySQL 8.0` 版本之后，表结构定义存放在系统数据表中了。

### 1.1 表数据

表数据既可以存在共享表空间中，又可以是单独的文件。这个行为由参数 `innodb_file_per_table` 控制的：

- 参数设置为 `ON`，每个 `InnoDB` 表数据存储在一个以 `.ibd` 为后缀的文件中，即独立表空间；
- 参数设置为 `OFF`，表的数据存放在系统共享表空间中。

在 `MySQL 5.7` 之后，这个参数的默认值就是 `ON`。

```mysql
mysql> show variables like 'innodb_file%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+

```



## 2. 数据删除流程

`InnoDB` 中的数据都是用 `B+` 树结构组织的，并且数据是按页存储的。当删除表数据时，一种情况是删除某个记录，`InnoDB` 引擎会把这个位置标记为删除，之后这个位置空间是可以复用的；另一种是删除了整页上的所有记录，那么整个数据页是可以复用的。但在上述这两种情况中，磁盘文件的大小都不会改变。

### 2.1 记录的复用和数据页的复用的区别

1. 记录的复用，是只限于新插入的数据符合原来范围条件的数据。例如原来删除的记录是在区间 (200，300) 内，而新插入的数据是 280，那么这个位置是可以复用的，而要插入 350 这个记录，就不能复用这个位置了。

2. 当整个数据页从 `B+` 树上摘掉之后，可以复用到任何位置。

因此，`delete` 命令只是把记录的位置，或者数据页标记为 "可复用"，但是对应的磁盘文件大小并不会改变。即，通过 `delete` 命令是没有回收表空间的，这些标记为 "可复用" 但又没有被使用的空间，称为 "数据空洞" ；

## 3. 数据的插入

实际中，不仅是数据的删除会造成 "数据空洞"，数据的插入也会造成这种情况。因为，数据的插入可能会造成页分裂，那么就有可能导致相邻的页上留下空洞。
另外，更新索引上的值，可以理解为删除一个旧值，再插入一个新值，那么也可能会造成空洞。

>   更新索引的操作，是不会修改主键索引树的位置是不会改变的，可能发生改变是的二级索引树。

因此，经过大量增删改的数据表，都是可能存在空洞的。当把这些表中的空洞去掉，就可以达到收缩表空间的目的。

## 4. 重建表

重建表，就是达到收缩表空间的目的。

### 4.1 场景模拟：现在存在一个表 `A`，需要做收缩空间，为了把表中的空洞去掉，可以怎么做？

可以新建一个表 `B`，按照主键 `id` 递增的顺序，将表 `A` 中的数据读出来，然后依次插入表 `B`，这样就可以排除掉表 `A` 中的空洞了。表 `B` 中的主键索更加紧凑，数据页的利用率更高。

我们可以使用命令 `alter table A engine = InnoDB` 来重建表。
在 `MySQL 5.5` 之前，这个命令的执行流程和上述场景描述的大致相同。区别是，这个临时表 `B` 不需要手动创建，而是 `MySQL` 会自动完成转存数据、交换表名、删除旧表等操作。

显然，上述过程中，花时间最多的是向临时表中插入数据的过程，如果在这个过程中，有新数据要插入表 `A` 的话，就会造成数据的丢失。因此，在整个 `DDL` 过程中，表 `A` 不能有更新操作，即，这个 `DDL` 过程不是 `Online` 的。

![](./pictures/recreate_1.png)

​																														改锁表 `DDL`

### 4.2 Online DDL

在 `MySQL 5.6` 之后，开始引入 `Online DDL`，对上述的这个操作流程进行了优化。
这个流程的主要优化是：
在生成临时文件的过程中，将所有对表 `A` 的操作记录在一个日志文件 ( `row log` ) 中，临时文件生成后，将日志文件中的操作应用到临时文件中，这样就得到了一个逻辑上和表 `A` 相同的数据文件。 
综上，由于日志文件记录和重放操作的存在，这个方案在重建表中的过程中，允许对原始表做 `DML` 操作，因此，就称为 `Online DDL` 的操作。

**更重要的一点：** 在 `DDL` 操作之前，要对数据表获取 `MDL` 写锁，那么还能称为 `Online` 吗？

确实，在 `alter` 语句在启动时需要获取 `MDL` 写锁，但这个写锁在真正拷贝数据之前就退化为读锁了。为什么会退化？
因为为了实现 `Online`，`MDL` 读锁是不会阻塞增删改操作，同时可以阻塞其他线程对这个表同时做 `DDL`。

![](./pictures/recreate_2.png)