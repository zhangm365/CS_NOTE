# 1. 为什么不要在 `DBMS` 中使用 `mmap`？

基于论文 "Are You Sure You Want to Use MMAP in Your Database Management System?" 的总结。

`DBMS` 中使用 `mmap` 实现内存映射文件 `I/O` 来替代传统的 `buffer pool` 模块，使得 `DBMS` 不需要管理自己的 `buffer pool`，而是交由操作系统管理。

例如，[`SQLite`](https://www.sqlite.org/mmap.html) 和 `MongoDB` 都使用基于 `mmap` 的存储引擎，但从 2019 年开始 `MongoDB` 已经完全不再使用 `mmap`，而是使用 [`WiredTiger`](https://www.mongodb.com/docs/manual/core/storage-engines/) 引擎。

`MongoDB` 早期使用基于 `mmap` 的存储引擎的设计有许多缺陷，例如为了数据正确性使用复杂地复制方案和不能在辅助存储设备上压缩数据。而 `rocksdb` 从 `leveldb` 新建分支，避免使用 `mmap` 而导致读性能瓶颈。

## 1.1 `mmap` 的缺陷

基于 `mmap` 的 `DBMS` 存在一些缺点：

### 1. 事务安全

由于透明分页，无论事务是否已提交，OS 都会随时将脏页写回磁盘。DBMS 无法阻止这些刷新操作，并在刷新时也不会收到任何警告。基于 `mmap` 的数据库管理系统必须部署复杂的协议保证透明页不会违反事务安全保证。`DBMS` 处理更新的措施可以分为几种：

1. OS COW

    使用 `mmap` 创建**数据库文件**的两份副本，两个文件指针最初都指向同一物理地址，第一个作为主副本，第二个作为事务更新时的私有工作区（使用 `MAP_PRIVATE` 实现 OS COW）。`DBMS` 事务更新的步骤如下：

    1. DBMS 的事务在私有工作区修改数据时，OS 将内容复制到新物理页并重新映射到虚拟地址，然后提交修改；
    2. 主副本看不到这些修改，OS 将不会持久化他们的内容到数据库文件；
    3. DBMS 使用 WAL 记录修改，当事务提交时，DBMS 将 WAL 刷盘保存。然后使用单独的后台线程将已提交的修改应用到主副本中。

    维护更新页的独立副本存在两个问题。第一，DBMS 必须保证事务已提交的最新修改必须传播到主副本，然后处理冲突事务的运行（例如，挂起的更新页）。第二，随着私有空间中的更新不断增长，DBMS 必须在内存中保存两份相同的副本数据。

2. User Space COW

    手动地将 mmap 支持的地址的修改数据拷贝到用户空间中单独维护的缓存区。

3. shadow paging

  使用 shadow paging 机制，DBMS 将数据库文件复制为单独两份：主副本和卷影副本。当事务更新时，DBMS首先将受影响的页从主副本复制到卷影副本，从而在卷影副本中应用必要的更改。提交更改包括使用 msync 将修改后的卷影页刷新到辅助存储，然后更新指针以将卷影副本安装为新的主副本，最初的主副本作为新的卷影副本。
