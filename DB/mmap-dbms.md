# 1. 为什么不要在 `DBMS` 中使用 `mmap`？

基于论文 "Are You Sure You Want to Use MMAP in Your Database Management System?" 的总结。

`DBMS` 中使用 `mmap` 实现内存映射文件 `I/O` 来替代传统的 `buffer pool` 模块，使得 `DBMS` 不需要管理自己的 `buffer pool`，而是交由操作系统管理。

例如，[`SQLite`](https://www.sqlite.org/mmap.html) 和 `MongoDB` 都使用基于 `mmap` 的存储引擎，但从 2019 年开始 `MongoDB` 已经完全不再使用 `mmap`，而是使用 [`WiredTiger`](https://www.mongodb.com/docs/manual/core/storage-engines/) 引擎。

`MongoDB` 早期使用基于 `mmap` 的存储引擎的设计有许多缺陷，例如为了数据正确性使用复杂地复制方案和不能在辅助存储设备上压缩数据。而 `rocksdb` 从 `leveldb` 新建分支，避免使用 `mmap` 而导致读性能瓶颈。

## 1.1 `mmap` 的缺陷

基于 `mmap` 的 `DBMS` 存在一些缺点：

### 1. 事务安全

由于透明分页，无论事务是否已提交，OS 都会随时将脏页写回磁盘。DBMS 无法阻止这些刷新操作，并在刷新时也不会收到任何警告。基于 `mmap` 的数据库管理系统必须部署复杂的协议保证透明页不会违反事务安全保证。`DBMS` 处理更新的措施可以分为几种：

1. OS COW

    使用 `mmap` 创建**数据库文件**的两份副本，两个文件指针最初都指向同一物理地址，第一个作为主副本，第二个作为事务更新时的私有工作区（使用 `MAP_PRIVATE` 实现 OS COW）。`DBMS` 事务更新的步骤如下：

    1. DBMS 的事务在私有工作区修改数据时，OS 将内容复制到新物理页并重新映射到虚拟地址，然后提交修改；
    2. 主副本看不到这些修改，OS 将不会持久化他们的内容到数据库文件；
    3. DBMS 使用 WAL 记录修改，当事务提交时，DBMS 将 WAL 刷盘保存。然后使用单独的后台线程将已提交的修改应用到主副本中。

    维护更新页的独立副本存在两个问题。第一，DBMS 必须保证事务已提交的最新修改必须传播到主副本，然后处理冲突事务的运行（例如，挂起的更新页）。第二，随着私有空间中的更新不断增长，DBMS 必须在内存中保存两份相同的副本数据。

2. User Space COW

    手动地将 mmap 支持的地址的修改数据拷贝到用户空间中单独维护的缓存区。

3. shadow paging

    使用 shadow paging 机制，DBMS 将数据库文件复制为单独两份：主副本和卷影副本。当事务更新时，DBMS首先将受影响的页从主副本复制到卷影副本，从而在卷影副本中应用必要的更改。提交更改包括使用 msync 将修改后的卷影页刷新到辅助存储，然后更新指针以将卷影副本安装为新的主副本，最初的主副本作为新的卷影副本。

### 2. I/O stalls

使用传统的 `buffer pool` 机制，DBMS 可以使用异步 I/O 来避免执行查询时阻塞线程。但 `mmap` 不支持异步读操作。

访问任何页可能会导致不期望的 I/O 挂起，因为 DBMS 不知道这些页是否在内存中。

### 3. 错误处理

DBMS 的一个核心功能是保证数据的一致性，因此访问数据时发生的错误处理是十分重要的。

通常地，可以在页级层面使用校验和检测页数据是否有破坏，但 `mmap` 默认将这些损坏的页面持久化到磁盘。

### 4. 性能

`mmap` 透明分页的最大和最显著的缺点是与性能有关。如果不重新设计操作系统级别，`mmap` 将无法避免严重的性能瓶颈。
主要存在三个问题：

1. 页表竞争

    OS 需要同步页面，在许多并发线程访问相同的页时，会引发页面表竞争。

2. 单线程驱逐页面机制

    OS 只能使用单线程来驱逐页面，这会达到 CPU 瓶颈。

3. TLB shootdowns

    CPU 产生处理器中断刷新每个核的 TLB，同步不同核之间 TLB 的一致性。
