# http报文：使用http协议交互的信息(应用层)



1. # **http报文**由报文首部、空行、报文主体组成。

-  ## 报文首部：服务端或客户端需处理的请求或响应的内容及属性；

-  ## 空行：用于划分报文首部和报文主体；

-  ## 报文主体：应被发送的内容；

    

    ## 请求端(客户端)发出的http报文称为请求报文，响应端(服务端)返回的http报文称为响应报文。

    

2. # 请求报文的结构

-  ## 由请求行、首部字段、空行、报文主体4部分组成；

-  ## 请求行：方法+URI+HTTP版本组成；

-  ## 其中首部字段： 请求首部、通用首部、实用首部、其他组成；



3. # 响应报文的结构

-  ## 由状态行、首部字段、空行、报文主体4部分组成。

-  ## 状态行：HTTP版本+状态码组成；

-  ## 其中首部字段包括：响应头部、通用头部、实用头部、其他组成。



4. # http状态码
-  ## http状态码负责描述客户端http请求的返回结果、标记服务端的处理是否正常、通知出现的错误等工作

-  ## 状态码的类别

| 编号 |               类别               |          原因短语          |
| :--: | :------------------------------: | :------------------------: |
| 1XX  |   Informational(信息性状态码)    |     接受的请求正在处理     |
| 2XX  |      Success（成功状态码）       |      请求正常处理完毕      |
| 3XX  |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |
| 4XX  | Client Error（客户端错误状态码） |     服务器无法处理请求     |
| 5XX  | Server Error（服务器错误状态码） |     服务器处理请求出错     |

-   ##  2XX 成功

    2XX的响应结果表示请求被服务器正常处理了

    |       状态码        |                           原因短语                           |
    | :-----------------: | :----------------------------------------------------------: |
    |       200 OK        | 表示从客户端发来的请求在服务端被正常处理，服务端返回对应的报文 |
    |   204 No Content    | 服务器接受的请求被成功处理，但返回的报文不含实体的主体部分(没有资源可返回) |
    | 206 Partial Content | 客户端进行了范围请求，响应报文中含Content-Range指定范围的实体内容 |

    

-   ## 3XX 重定向

    3XX 响应结果表明浏览器需要执行某些特殊处理以正确处理请求

    |         状态码         |                           原因短语                           |
    | :--------------------: | :----------------------------------------------------------: |
    | 301 Moved Permanently  | 永久性重定向。表示请求的资源已被重新分配URI，以后访问资源应该使用新URI。(永久改变) |
    |       302 Found        | 临时性重定向。表示请求的资源已被重新分配URI，希望这次访问用新的URI。 |
    |     303 See Other      | 请求的资源含有另一个URI，应使用GET方法定向获取请求的资源。与302类似，但用303是最理想的 |
    |  **304 Not Modified**  | 客户端发送**附带条件**的请求时，服务端允许访问资源，但因发生请求未满足条件的情况后，直接返回304(服务器资源未改变，可直接使用客户端未过期的缓存)。<br>附带条件：使用GET方法时的请求报文中含：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 任一首部 |
    | 307 Temporary Redirect |                    临时重定向。和302类似                     |

    

-   ## 4XX 客户端错误

    4XX表示客户端是发生错误的原因所在

    |      状态码      |                           原因短语                           |
    | :--------------: | :----------------------------------------------------------: |
    | 400 Bad Request  |  请求报文中存在语法错误。需要修改请求的内容后再次发送请求。  |
    | 401 Unauthorized | 表示发送的请求需要有通过HTTP认证的信息。通常发送请求后会出现认证失败的响应。 |
    |  403 Forbidden   | 表示请求的资源被服务器拒绝了。比如未获得文件系统的访问授权，访问权限出现问题(IP未授权)等 |
    |  404 Not Found   |                  表示服务器未找到请求的资源                  |



-   ## 5XX 服务端错误

    5XX表示服务端本身发生错误

    |          状态码           |                       原因短语                       |
    | :-----------------------: | :--------------------------------------------------: |
    | 500 Internal Server Error |              服务器在执行请求时发生错误              |
    |  503 Service Unavailable  | 服务器暂时处于超负荷运行或停机维护，现在无法处理请求 |

     


5.  # HTTP方法(http/1.1)

    |                           方法                           |                             请求                             |                             响应                             |
    | :------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
    |                      GET：获取资源                       |       GET  /index.html  HTTP/1.1<br>Host: www.hackr.jp       |                    返回index.html页面资源                    |
    |                    POST：传送实体主体                    | POST  /submit.cgi  HTTP/1.1<br>Host: www.hackr.jp<br>Content-length: 1560(字节的数据) |                 返回submit.cgi接受数据的结果                 |
    |                      PUT：传输文件                       | PUT  /example.html  HTTP/1.1<br>Host: www.hackr.jp<br>Content-Type: text/html<br>Content-Length: 1560（字节的数据） | 响应返回状态码 204 No Content（比如 ：该 html 已存在于服务器上） |
    |  HEAD：获取报文首部<br>和GET方法类似，但不返回报文主体   |      HEAD  /index.html  HTTP/1.1<br/>Host: www.hackr.j       |                 返回index.html有关的响应首部                 |
    |            DELETE：删除文件<br>和PUT方法相反             |                                                              |                                                              |
    | OPTIONS：支持询问的方法<br>查询针对请求URI资源支持的方法 |           OPTIONS * HTTP/1.1<br>Host: www.hackr.jp           | HTTP/1.1  200  OK<br>Allow: GET, POST, HEAD, OPTIONS（返回服务器支持的方法） |
    |                     TRACE：追踪路径                      |                                                              |                                                              |
    |             CONNECT：要求用隧道协议连接代理              |                                                              |                                                              |

    6.  # http是无状态协议&Cookie技术

    -   ## http是无状态协议，它不会对之前发过的请求和响应的状态进行管理，即无法根据之前的状态进行本次的请求处理。例如：有登录认证的Web页面本身无法进行状态的管理(不记录已登录的状态)，那么每次跳转到新页面就要再次登录。

    -   ## 为解决上述问题，引入Cookie技术。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。例如以下场景：

        1.  ### 请求报文（没有 Cookie 信息的状态）

            GET /reader/ HTTP/1.1
            
            Host: hackr.jp
            
            *首部字段内没有Cookie的相关信息
                    
        
        2.  ### 响应报文（服务器端生成 Cookie 信息）
        
            HTTP/1.1 200 OK
        
            Date: Thu, 12 Jul 2012 07:12:20 GMT
        
            Server: Apache
            ＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞
            Content-Type: text/plain; charset=UTF-8
        
            
        
        3.  ### 请求报文（自动发送保存着的 Cookie 信息）
        
            GET /image/ HTTP/1.1
            Host: hackr.jp
        
            Cookie: sid=1342077140226724

7.  # HTTPS与HTTP

    1.  ## HTTP存在的问题

        -   通信使用明文(不加密)，内容可能被窃听；
        -   不验证通信方的身份，因此有可能遭遇伪装；
        -   无法验证报文的完整性，所以有可能被篡改。

    2.  ## HTTPS = HTTP+加密+认证+完整性保护

        HTTPS在HTTP协议的基础上使用SSL/TLS协议构建可以加密传输、身份认证的网络协议。因此，https协议可以建立信息安全通道，保证数据传输的可靠性；同时可以确保网站的真实性；SSL是当今世界应用最广泛的网络安全技术。

    3.  ## 对称加密和非对称加密

        -   对称加密：加密和解密使用同一个密钥的方式；

        -   非对称加密：包含私有密钥(private key)和公有密钥(public key)两个密钥。私有密钥是不能让任何人知道的，公有密钥可以随意发布。

        -   非对称加密方式：发送密文的一方可以使用对方的公有密钥加密，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

    4.  ## HTTPS采用对称加密和非对称加密的混合机制

        加密过程：

        1.  使用非对称加密方式安全地交换稍后使用的对称密钥中的密钥；
        2.  在确保对称密钥安全的情况下，使用对称密钥加密方式进行通信；

        

    5.  ## 验证公开密钥正确性的证书

        如何验证服务器发回的公开密钥是正确的？

        1.  可由**数字证书认证机构**(CA)及其相关机构颁发的公开密钥证书。服务器的人员向CA提出公开密钥的申请，CA在验证申请者的身份后，对已申请的公钥做数字签名，并将该公钥放入公钥证书后绑定在一起，即数字证书包括：服务器的公钥和CA的数字签名。

        2.  服务器会将这份有CA颁发的公钥证书发送给客户端，以进行非对称密钥加密通信。

        3.  接到证书的客户端可使用CA的公开密钥，对证书上的数字签名进行验证，一旦验证通过，即明确两件事：

            3.1 认证服务器的公开密钥是真实有效的数字证书认证机构；

            3.2 服务器的公开密钥是真实可靠的。

        4.  之后客户端可以使用服务器的公开密钥进行报文加密通信。

    6.  

    

    