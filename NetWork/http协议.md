- [`HTTP `协议与报文](#http-协议与报文)
  - [1. ``HTTP``报文组成部分](#1-http报文组成部分)
  - [2. 请求报文的结构](#2-请求报文的结构)
  - [3. 响应报文的结构](#3-响应报文的结构)
  - [4. `HTTP` 状态码](#4-http-状态码)
  - [5. 请求首部字段](#5-请求首部字段)
    - [5.1 `If-Match`](#51-if-match)
    - [5.2 `If-None-Match`](#52-if-none-match)
    - [5.3 `If-Modified-Since `](#53-if-modified-since-)
    - [5.4 `If-Unmodified-Since`](#54-if-unmodified-since)
    - [5.5 `If-Range`](#55-if-range)
  - [6. `HTTP` 方法 (`HTTP/1.1`)](#6-http-方法-http11)
    - [6.1 `HTTP` 长连接](#61-http-长连接)
  - [6. `http` 是无状态协议 & `Cookie`技术](#6-http-是无状态协议--cookie技术)
  - [7. `HTTPS`& `HTTP`](#7-https-http)
    - [7.1 `HTTP`存在的问题](#71-http存在的问题)
    - [7.2 `HTTPS `= `HTTP`+加密+认证+完整性保护](#72-https--http加密认证完整性保护)
    - [7.3 对称加密和非对称加密](#73-对称加密和非对称加密)
    - [7.4 `HTTPS` 采用对称加密和非对称加密的混合机制](#74-https-采用对称加密和非对称加密的混合机制)
    - [7.5 验证公开密钥正确性的证书](#75-验证公开密钥正确性的证书)

# `HTTP `协议与报文

## 1. ``HTTP``报文组成部分

`HTTP` 报文是在应用层使用 `HTTP` 协议交互的信息载体。它由 **报文首部、空行、报文主体** 三部分组成。

- 报文首部：服务端或客户端需处理的请求或响应的内容及属性；

- 空行：用于划分报文首部和报文主体<CR LF>；

- 报文主体：应被发送的内容；

请求端(客户端)发出的 `HTTP` 报文称为 **请求报文**，响应端(服务端)返回的 `HTTP` 报文称为 **响应报文**。

## 2. 请求报文的结构

由 **请求行、首部字段、空行、报文主体** 四部分组成；

- 请求行：方法 + `URI` + `HTTP`版本三部分组成；
- 其中首部字段： 请求首部、通用首部、实用首部、其他组成；
- 报文主体：报文中的具体内容。

## 3. 响应报文的结构

由 **状态行、首部字段、空行、报文主体** 四部分组成。

- 状态行：`HTTP`版本 + 状态码 + 原因短语三部分组成；
- 其中首部字段包括：响应首部、通用首部、实用首部、其他组成。
- 报文主体：报文中的具体内容。

## 4. `HTTP` 状态码

`HTTP` 状态码负责描述客户端 `HTTP` 请求的返回结果、标记服务端的处理是否正常、通知出现的错误等工作。状态码的类别如下：

| 编号  |                类别                |          原因短语          |
| :---: | :--------------------------------: | :------------------------: |
| `1XX` |   `Informational`(信息性状态码)    |     接受的请求正在处理     |
| `2XX` |      `Success`（成功状态码）       |      请求正常处理完毕      |
| `3XX` |   `Redirection`（重定向状态码）    | 需要进行附加操作以完成请求 |
| `4XX` | `Client Error`（客户端错误状态码） |     服务器无法处理请求     |
| `5XX` | `Server Error`（服务器错误状态码） |     服务器处理请求出错     |

- `2XX `成功

    `2XX` 的响应结果表示请求被服务器正常处理了

    |        状态码         |                           原因短语                           |
    | :-------------------: | :----------------------------------------------------------: |
    |       `200 OK`        | 表示从客户端发来的请求在服务端被正常处理，服务端返回对应的报文 |
    |   `204 No Content`    | 服务器接受的请求被成功处理，但返回的报文不含实体的主体部分(没有资源可返回) |
    | `206 Partial Content` | 客户端进行了范围请求，响应报文中含`Content-Range`指定范围的实体内容 |

    

- `3XX` 重定向

    `3XX `响应结果表明浏览器需要执行某些特殊处理以正确处理请求

    |          状态码          | 原因短语                                                     |
    | :----------------------: | :----------------------------------------------------------- |
    | `301 Moved Permanently`  | 永久性重定向。表示请求的资源已被重新分配`URI`，以后访问资源应该使用新`URI`。(永久改变) |
    |       `302 Found`        | 临时性重定向。表示请求的资源已被重新分配`URI`，希望这次访问用新的`URI`。 |
    |     `303 See Other`      | 请求的资源含有另一个`URI`，应使用`GET`方法定向获取请求的资源。与`302`类似，但用`303`是最理想的。 |
    |  **`304 Not Modified`**  | 客户端发送 **附带条件** 的请求时，服务端允许访问资源，但因发生请求未满足条件的情况后，直接返回`304`(服务器资源未改变，可直接使用客户端未过期的缓存)。<br />附带条件：使用`GET`方法时的请求报文中含：`If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since` 任一首部字段。 |
    | `307 Temporary Redirect` | 临时重定向。和`302`类似                                      |

    

- `4XX` 客户端错误

    `4XX` 表示客户端是发生错误的原因所在

    |       状态码       |                           原因短语                           |
    | :----------------: | :----------------------------------------------------------: |
    | `400 Bad Request`  |  请求报文中存在语法错误。需要修改请求的内容后再次发送请求。  |
    | `401 Unauthorized` | 表示发送的请求需要有通过`HTTP`认证的信息。通常发送请求后会出现认证失败的响应。 |
    |  `403 Forbidden`   | 表示请求的资源被服务器拒绝了。比如未获得文件系统的访问授权，访问权限出现问题(`IP`未授权)等 |
    |  `404 Not Found`   |                  表示服务器未找到请求的资源                  |



- `5XX `服务端错误

    `5XX` 表示服务端本身发生错误

    |           状态码            |                       原因短语                       |
    | :-------------------------: | :--------------------------------------------------: |
    | `500 Internal Server Error` |              服务器在执行请求时发生错误              |
    |  `503 Service Unavailable`  | 服务器暂时处于超负荷运行或停机维护，现在无法处理请求 |

## 5. 请求首部字段

请求首部字段是客户端给服务端发送请求报文中所使用的字段，用于补充附加信息、客户端信息、对响应内容相关的优先级等内容。

### 5.1 `If-Match`

形如 `If-xxx` 的请求首部字段，都称为 **条件请求**。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会处理请求。

例如，当请求报文中含有  `If-Match` 字段时，那么只有当 `If-Match` 指定的字段值和服务器上资源所用的实体标记 `ETag` 值匹配时，服务器才会接受请求。

> 实体标记 `ETag` 是与特定资源关联的确定值，资源更新后 `ETag` 也会随之更新。 

例如以下请求报文：

```http
GET /index.html HTTP/1.1
Host: www.hackr.jp
If-Match: "123456"
```

当服务器上的资源 `/index.html` 的实体标记 `ETag` 是 "`123456`" 时，则服务器正确处理请求。

```http
HTTP/1.1 200 OK
```

### 5.2 `If-None-Match`

该字段表示只有在指定的值和 `ETag` 值不一样时，才处理该请求。与 `If-Match` 字段语义相反。

### 5.3 `If-Modified-Since `

该字段表示在指定日期之后服务器的资源是否更新。

例如以下请求报文：

```http
GET /index.html HTTP/1.1
Host: www.hackr.jp
If-Modified-Since: Thu, 15 Apr 2021 00:00:00 GMT
```

如果在指定日期之后，对应的服务器资源有更新，那么返回含有 `Last-Modified` （资源最后更新的时间）字段的响应报文：

```http
HTTP/1.1 200 OK
Last-Modified: Sun, 29 Apr 2021 14:03:05 GMT 
```

如果在指定日期之后，对应的资源没有更新，则返回 `304 Not Modified`：

```http
HTTP/1.1 304 Not Modified
```

### 5.4 `If-Unmodified-Since`

首部字段 `If-Unmodified-Since` 和 `If-Modified-Since` 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 `412 Precondition Failed` 作为响应返回。

### 5.5 `If-Range`

该字段表示告知服务器其指定的值（`ETag` 或 时间）和请求资源的 `ETag` 或时间一致时，则作为范围请求处理。反之，返回全部资源。

## 6. `HTTP` 方法 (`HTTP/1.1`)

|                            方法                            | 请求                                                         |                             响应                             |
| :--------------------------------------------------------: | :----------------------------------------------------------- | :----------------------------------------------------------: |
|                      `GET`：获取资源                       | `GET  /index.html  HTTP/1.1`<br>`Host: www.hackr.jp`         |                   返回`index.html`页面资源                   |
|                    `POST`：传送实体主体                    | `POST  /submit.cgi  HTTP/1.1`<br>`Host: www.hackr.jp`<br>`Content-length: 1560(字节的数据)` |                返回`submit.cgi`接受数据的结果                |
|                      `PUT`：传输文件                       | `PUT  /example.html  HTTP/1.1` <br>`Host: www.hackr.jp` <br>`Content-Type: text/html` <br>`Content-Length: 1560`（字节的数据） | 响应返回状态码 `204 No Content`<br>（比如 ：该 `html` 已存在于服务器上） |
|                    `HEAD`：获取报文首部                    | `HEAD  /index.html  HTTP/1.1` <br/>`Host: www.hackr.jp`      | 返回`index.html`有关的响应首部<br>和`GET`方法类似，但不返回报文主体 |
|           `DELETE`：删除文件<br>和`PUT`方法相反            |                                                              |                                                              |
| `OPTIONS`：支持询问的方法<br>查询针对请求URI资源支持的方法 | `OPTIONS * HTTP/1.1`<br>Host: `www.hackr.jp`                 | `HTTP/1.1  200  OK`<br>`Allow: GET, POST, HEAD, OPTIONS`（返回服务器支持的方法） |
|                     `TRACE`：追踪路径                      |                                                              |                                                              |
|             `CONNECT`：要求用隧道协议连接代理              |                                                              |                                                              |



### 6.1 `HTTP` 长连接

在旧的`HTTP` 协议中，`Web`服务器与`Web`客户端之间的一个`TCP`连接只能为一次`HTTP`请求服务，即服务端每次处理完一个`HTTP`请求后，`Web`服务端就主动关闭`TCP`连接了。那么，在下次同一客户再次发送一个`HTTP`请求时，客户端与服务端需要重新建立一个新的`TCP`连接。所以，这会导致同一客户端的多个连续的`HTTP`请求不能共用一个`TCP`连接，这称为短连接。长连接，就是同一客户端的多个`HTTP`请求可以共用同一个`TCP`连接，极大地提高了每次`HTTP`请求处理的性能。在`HTTP/1.1`版本中，默认使用持久连接。

如下是访问 `www.baidu.com` 的请求报文首部信息：

```http
GET /index.html HTTP/1.1
Host: www.baidu.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*; q=0.8
Accept-Language: ja,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive
If-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMT
If-None-Match: "45bae1-16a-46d776ac"
Cache-Control: max-age=0
```

- 第一行是请求行。其中"`GET`"是请求方法，表示客户端向服务器请求获取资源。"`/index.html`"是目标资源的URI，"`HTTP/1.1`" 表示当前使用`HTTP`协议的版本是`1.1`。
- "`Connection: keep-alive`"  字段表示当前建立的连接是持久连接。若为`close`字段值，则表示处理完一个请求之后，立即关闭当前建立的连接。

以下是之前请求访问的 `www.baidu.com` 返回的 `HTTP` 响应报文头部：

```http
HTTP/1.1 304 Not Modified
Date: Thu, 07 Jun 2012 07:21:36 GMT
Server: Apache
Connection: keep-alive
Etag: "45bae1-16a-46d776ac"
```

- 第一行是状态码。"`HTTP/1.1`" 表示`HTTP`协议版本号。
- "`304 Not Modified`" 是状态码和原因短语。 表示对请求报文中的头部字段 `If-Modified-Since` 指定的日期之后服务器的资源没有发生更新的响应。



## 6. `http` 是无状态协议 & `Cookie`技术

`http`是无状态协议，它不会对之前发过的请求和响应的状态进行管理，即无法根据之前的状态进行本次的请求处理。例如：有登录认证的`Web`页面本身无法进行状态的管理(不记录已登录的状态)，那么每次跳转到新页面就要再次登录。

为解决上述问题，引入`Cookie`技术。`Cookie`技术通过在请求和响应报文中写入`Cookie`信息来控制客户端的状态。例如以下场景：

1. 请求报文（没有 `Cookie `信息的状态）

    ```http
    GET /reader/ HTTP/1.1
    Host: www.hackr.jp
    ```

    第一次客户端发起请求报文时，没有 `Cookie` 信息。        

2. 响应报文（服务器端生成 `Cookie `信息）

    ```http
    HTTP/1.1 200 OK
    Date: Thu, 12 Jul 2012 07:12:20 GMT
    Server: Apache
    <Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT>
    Content-Type: text/plain; charset=UTF-8
    ```

    在服务端返回客户端的响应报文内，设置 `Set-Cookie` 头部字段通知客户端保存 `Cookie` 信息。

3. 请求报文（自动发送保存着的 `Cookie `信息）

    ```http
    GET /image/ HTTP/1.1
    Host: www.hackr.jp
    Cookie: sid=1342077140226724
    ```

    第三次，客户端已经保存了服务端发来的 `Cookie` 状态信息，这次发起的请求报文会添加 `Cookie` 后发送给服务端。

## 7. `HTTPS`& `HTTP`

`HTTP` 协议默认端口后是 `80` ，`HTTPS` 使用的是 `443` 端口。

### 7.1 `HTTP`存在的问题

- 通信使用明文(不加密)，内容可能被窃听；
- 不验证通信方的身份，因此有可能遭遇伪装；
- 无法验证报文的完整性，内容有可能被篡改。

### 7.2 `HTTPS `= `HTTP`+加密+认证+完整性保护

`HTTPS` 在`HTTP`与 `TCP` 层之间加入了`SSL/TLS`协议，这样可以构建加密传输、身份认证的网络协议。因此，`HTTPS`协议可以建立信息安全通道，保证数据传输的可靠性；同时可以确保网站的真实性。`SSL`是当今世界应用最广泛的网络安全技术。

### 7.3 对称加密和非对称加密

- 对称加密：加密和解密使用同一个密钥；

- 非对称加密：包含私有密钥(`private key`)和公有密钥(`public key`)两个密钥。私有密钥是不能让任何人知道的，公有密钥可以随意发布。

- 非对称加密方式：发送密文的一方可以使用对方的公有密钥加密，对方收到被加密的信息后，再使用自己的私有密钥进行解密。

### 7.4 `HTTPS` 采用对称加密和非对称加密的混合机制

加密过程：

1. 使用非对称加密方式安全地交换稍后使用的对称密钥中的密钥；
2. 在确保对称密钥安全的情况下，使用对称密钥加密方式进行通信；

### 7.5 验证公开密钥正确性的证书

如何验证服务器发回的公开密钥是正确的？

1. 可由 **数字证书认证机构**(`CA`) 及其相关机构颁发的公开密钥证书。服务器的人员向`CA`提出公开密钥的申请，`CA`在验证申请者的身份后，对已申请的公钥做数字签名，并将该公钥放入公钥证书后绑定在一起，即数字证书包括：服务器的公钥和`CA`的数字签名。

2. 服务器会将这份有`CA`颁发的公钥证书发送给客户端，以进行非对称密钥加密通信。

3. 接到证书的客户端可使用`CA`的公开密钥，对证书上的数字签名进行验证，一旦验证通过，即明确两件事：

    - 认证服务器的公开密钥是真实有效的数字证书认证机构；

    - 服务器的公开密钥是真实可靠的。

4. 客户端使用服务器的公开密钥进行报文加密通信，然后服务端用私有密钥对报文进行解密。

