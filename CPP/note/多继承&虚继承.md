[toc]

# 多继承与虚继承

---------------

## 1. 多重继承

多重继承是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。
在派生类的派生列表中可以包含多个基类，每个基类包含一个可选的访问说明符。如下示例：

```cpp
class Bear : public ZooAnimal { /* */ };
class Panda : public Bear, public Endangered { /* */ };

```

因此，在多重的继承关系中，每个派生类的对象包含每个基类的子对象。那么，构造一个派生类对象将同时构造并初始化它的所有基类子对象。
基类的构造顺序与派生列表中基类的出现顺序保持一致。

## 2. 虚继承

`IO` 标准库的 `istream` 和 `ostream` 分别继承了一个共同的名为 `base_ios` 的抽象基类。该抽象基类负责保存流的缓冲内容并管理流的条件状态。`iostream` 是另一个类，它从 `istream` 和 `ostream` 直接继承而来，可以同时读写流的内容。因为 `istream` 和 `ostream` 都继承自 `base_ios`，所以 `iostream` 继承了 `base_ios` 两次，一次通过 `istream` 继承而来，一次通过 `ostream` 继承而来。如下图：

![](.\pics\std-io-complete-inheritance.svg)

默认情况下，派生类含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类将包含该类的多个子对象。
但是，这种默认情况对于 `iostream` 类是行不通的。一个 `iostream` 对象希望在同一个缓冲区进行读写操作，也会要求条件状态能同时反映输入和输出操作的情况。

`C++` 中通过 **虚继承** 的机制来解决上述问题的。虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类。
在这种情况下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

**虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。**

```cpp
class Base {};

class D1 : virtual public Base {};	// virtual 和 public 关键字顺序随意。

class D2 : virtual public Base {};

// 上述代码将 Base 定义 D1, D2 的虚基类
class D : public D1, publib D2 {};

// 类 D 中只有一个 Base 基类部分。 
```

