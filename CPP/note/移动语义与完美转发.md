# 移动语义与完美转发

- [移动语义与完美转发](#移动语义与完美转发)
  - [1. `remove_reference`](#1-remove_reference)
  - [2. 移动语义](#2-移动语义)
  - [3. 完美转发](#3-完美转发)
    - [3.1 `std::forward` 源码](#31-stdforward-源码)

## 1. `remove_reference`

`remove_reference` 是去掉类型的引用部分，只获取它的类型部分。以下是它的源码：

```cpp
/**
 * @brief type trait: Remove reference from type.
 * remove_reference<_Tp>::type = _Tp
 * remove_reference<_Tp&>::type = _Tp
 * remove_reference<_Tp&&>::type = _Tp
 */
template<typename _Tp>
struct remove_reference
{ typedef _Tp type; };

// 特化版本
template<typename _Tp>
struct remove_reference<_Tp&>
{ typedef _Tp type; };

template<typename _Tp>
struct remove_reference<_Tp&&>
{ typedef _Tp type; };
```

## 2. 移动语义

标准库中的 `std::move` 实现原理。

```cpp
template<typename _Tp>  
constexpr typename std::remove_reference<_Tp>::type&& 
move(_Tp&& __t) noexcept { 
    return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); 
}
```

`std::move` 的功能是：

- 传递的是左值，推导为左值引用，仍旧 `static_cast` 转换为右值引用。
- 传递的是右值，推导为右值引用，仍旧 `static_cast` 转换为右值引用。

函数的返回值直接是右值引用返回类型，即 `std::remove_reference<_Tp>::type&&` 就是一个右值引用。

## 3. 完美转发

标准库 `std::forward` 函数可以在函数调用过程中保持原始实参的类型信息。万能引用和 `std::forward` 的组合可以准确实现完美转发的功能。

### 3.1 `std::forward` 源码

```cpp
/**
 * @brief Forward an lvalue. 转发左值
 * @return The parameter cast to the specified type.
 *
 * This function is used to implement "perfect forwarding".
 */

template<typename _Tp>
constexpr _Tp&& 
forward(typename std::remove_reference<_Tp>::type& __t) noexcept {
    return static_cast<_Tp&&>(__t);
}

/**
 * @brief Forward an rvalue. 转发右值
 * @return The parameter cast to the specified type.
 *
 * This function is used to implement "perfect forwarding".
 */

template<typename _Tp>
constexpr _Tp&&
forward(typename std::remove_reference<_Tp>::type&& __t) noexcept {
    // 断言表示参数不是一个左值时，即是右值才进行 static_cast 转换。
    static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                   " substituting _Tp is an lvalue reference type");
    return static_cast<_Tp&&>(__t);
}
 
```

例如以下代码示例：

```cpp
#include <iostream>
#include <utility>
template <typename T>
void print( T& val ) {
    printf("print(T&)\n");
}

template <typename T>
void print( T&& val ) {
    printf("print(T&&)\n");
}

template <typename T>
void temTest( T&& v ) {
    print(v);   // 总是调用 print( T& )
    print(std::forward<T>(v));    // 完美转发
    print(std::move(v));    // 总是调用 print(T&&)
}

int main() {
    int i = 0;
    temTest(i);
    printf("===============\n");   
    temTest(std::move(i));
    return 0;
}
```
