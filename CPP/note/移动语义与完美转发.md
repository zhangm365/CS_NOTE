# 移动语义与完美转发

- [移动语义与完美转发](#移动语义与完美转发)
  - [1. `std::remove_reference`](#1-stdremove_reference)
  - [2. 移动语义](#2-移动语义)
  - [3. 完美转发](#3-完美转发)
    - [3.1 `std::forward` 源码](#31-stdforward-源码)

## 1. `std::remove_reference`

`std::remove_reference` 是去掉类型的引用部分，只获取它的类型部分。以下是它的源码：

```cpp
/**
 * @brief type trait: Remove reference from type.
 * remove_reference<T>::type = T
 * remove_reference<T&>::type = T
 * remove_reference<T&&>::type = T
 */

template<typename T>
struct remove_reference
{ typedef T type; };

// 1. 特化版本: 左值引用
template<typename T>
struct remove_reference<T&>
{ typedef T type; };

// 2. 特化版本：右值引用
template<typename T>
struct remove_reference<T&&>
{ typedef T type; };

// helper types: since C++14
template<class T>
using remove_reference_t = typename remove_reference<T>::type;
```

## 2. 移动语义

标准库 `std::move` 的实现原理。

```cpp
/**
 * @brief 移动语义，接受任何类型的实参，返回一个右值引用。
 * @param T&&: 指向模板类型参数的右值引用。
 * @return 模板参数的限定类型名依赖: typename std::remove_reference<T>::type&&
 */

template<class T>  
constexpr std::remove_reference_t<T>&& 
move(T&& t) noexcept { 
    return static_cast<typename std::remove_reference<T>::type&&>(t); 
}
```

`std::move` 的参数类型推导过程：

- 实参是左值，编译器推断 `T` 类型为左值引用类型 `T&`，函数参数 `T& &&` 引用折叠为 `T&`。
- 实参是右值，编译器推断 `T` 类型为该右值的类型，函数参数为 `T&&`。

函数的返回值是**右值引用类型**，最终由 `static_cast` 转换为右值引用。

## 3. 完美转发

标准库 `std::forward` 函数可以在函数调用过程中保持原始实参的类型信息。万能引用和 `std::forward` 的组合可以准确实现完美转发的功能。

### 3.1 `std::forward` 源码

```cpp
/**
 * @brief Forward an lvalue. 转发左值
 * @return The parameter cast to the specified type.
 *
 * This function is used to implement "perfect forwarding".
 */

template<typename T>
constexpr T&& 
forward(typename std::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

/**
 * @brief Forward an rvalue. 转发右值
 * @return The parameter cast to the specified type.
 *
 * This function is used to implement "perfect forwarding".
 */

template<typename T>
constexpr T&&
forward(typename std::remove_reference<T>::type&& t) noexcept {
    // 断言表示参数不是一个左值时，即是右值才进行 static_cast 转换。
    static_assert(!std::is_lvalue_reference<T>::value, "template argument"
                   " substituting T is an lvalue reference type");
    return static_cast<T&&>(t);
}
 
```

例如以下代码示例：

```cpp
#include <iostream>
#include <utility>
template <typename T>
void print( T& val ) {
    printf("print(T&)\n");
}

template <typename T>
void print( T&& val ) {
    printf("print(T&&)\n");
}

template <typename T>
void temTest( T&& v ) {
    print(v);   // 总是调用 print( T& )
    print(std::forward<T>(v));    // 完美转发
    print(std::move(v));    // 总是调用 print(T&&)
}

int main() {
    int i = 0;
    temTest(i);
    printf("===============\n");   
    temTest(std::move(i));
    return 0;
}
```
