[toc]

# 构造函数

----



## 1 . 定义

构造函数是与类同名的成员函数，可以有形参，但没有返回值。

它可以完成对类中数据的初始化工作。在一个构造函数中，成员的初始化是在函数体执行之前完成的。

构造函数可以重载。

# 拷贝构造函数

---



## 1 . 定义

如果一个构造函数的第一个参数是自身类类型的 **引用** ，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```c++
class Foo
{
	public:
		Foo();	// 默认构造函数	
		Foo( const Foo & )	// 拷贝构造函数
};
```

拷贝构造函数自己的参数必须是引用类型，否则会陷入无限循环调用状态。

## 2 . 直接初始化和拷贝初始化

### 2.1  定义 

1.  直接初始化：不使用 `=` 初始化一个新建变量；

2.  拷贝初始化：使用 `=` 初始化一个新建变量；

    ```c++
    string s1("hello");		// 直接初始化
    string s2 = "world";	// 拷贝初始化
    string s3(10, 'c');		// 直接初始化
    ```

当执行 **直接初始化** 时，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。

而当执行 **拷贝初始化** 时，是要求编译器将右侧对象拷贝到正在创建的对象中。拷贝初始化通常使用拷贝构造函数进行来完成的。

### 2.2  拷贝初始化发生情况

1.  在用 `=` 定义变量时；
2.  将一个对象作为实参传给一个非引用类型的形参；
3.  从一个返回类型是非引用类型的函数返回一个对象；
4.  用花括号初始化一个数组中的元素或一个聚合类中的成员；

# 拷贝赋值运算符

---



## 1 . 定义

类不但可以控制它的对象如何初始化一样，类也可以控制其对象如何赋值。拷贝赋值运算符通常组合了析构和拷贝构造函数的工作。例如以下：

```c++
Sales_data trans, accum;
trans = accum;	// 使用 Sales_data 的拷贝赋值运算符
```

重载运算符本质上是函数，其名字由 **`operator`** 关键字后接表示要定义的运算符的符号组成。

因此，赋值运算符就是 **`operator=`** 的函数。 赋值运算符需要定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 **`this`** 参数。

```c++
class Foo
{
	public:
		Foo& operator=( const Foo& );	// 赋值运算符
};
```

赋值运算符通常应该返回一个指向其左侧运算对象的引用。

# 析构函数

---



## 1 . 定义

析构函数是由波浪号和类名构成的一个类的成员函数。它没有返回值，也不接受参数。

在析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

析构函数不支持重载。

# 联系

---



## 1 . 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值函数。

## 2 . 需要拷贝构造函数的类，几乎可以肯定也需要一个拷贝赋值函数。

# 阻止拷贝

---

## 1 . 定义

新标准下，可以将 **拷贝构造函数** 和 **拷贝赋值函数** 定义为删除的函数来阻止拷贝。

删除的函数：虽然声明了它们，但不能以任何方式使用它们。在函数参数列表后面加 `=delete` 来指出该函数定义为删除的。

```c++
class NoCopy
{
	public:
    	NoCopy() = default;	// 告诉编译器使用合成的默认构造函数
    	NoCopy( const NoCopy & ) = delete;	// 阻止拷贝
    	NoCopy &operator=( const NoCopy & ) = delete;	// 阻止赋值
    
};
```

## 2 . 使用方法

析构函数不能定义为删除的成员，否则编译器将不允许定义该类型的变量。



