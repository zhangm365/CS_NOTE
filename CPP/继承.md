[toc]

# 基类&派生类

--------------------------

## 1. 基类

面向对象编程设计中，通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部是基类，其他类直接或间接从基类继承而来，这些继承而来的类称为派生类。

静态类型：变量或表达式的静态类型在编译时就已知的；
动态类型：变量或表达式表示的是内存中的对象的类型，在运行时解析得知。

## 2. 派生类

### 2.1 要点

1.  派生类对象可以访问基类的 `public` 、`protected` 访问控制符下的成员；

2.  因为派生类对象含有与基类对应的组成部分，所以派生类对象可以当成基类对象使用；

3.  基类的指针或引用可以绑定到派生类对象，即**派生类自动转换成基类对象的类型**；

4.  派生类必须使用**基类的构造函数**来初始化它的基类部分；

5.  在一个类名后面加关键字 `final` ，可以防止此类被其他类继承；

    ```cpp
    class NoDerived final {};	// NoDerived 不能被当做基类
    class Base {};
    class Last final : public Base {};	// 类 Last 不可以被继承
    class Bad : public NoDerived {};	// error : 类 NoDerived 不可以被继承
    class Bad2 : public Last {};	// error
    ```

6.  不能将基类转换成派生类。

7.  当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、赋值或移动，它的派生类部分会被忽略掉。

    ```cpp
    class Base {};
    class Derived : publid Base {};
    
    Derived d1;
    Base b1(d1);	// 使用 Base::Base( const Base & ) 构造函数
    b1 = d1;	// 调用 Base::operator=( const Base & ) 
    ```

8.  动态绑定只有当通过指针或引用调用虚函数才会发生；
9.  派生类中的虚函数要覆盖基类中的虚函数时，这两个虚函数的形参必须严格匹配；

## 3. final & override

### 3.1 override 关键字

当派生类定义一个函数和基类中虚函数的名字相同但形参列表不同，编译器会认为这是派生类中定义的一个新函数，与基类中原有的虚函数是独立的。因此，派生类的函数并没有覆盖掉基类中的版本，但就实际的编程习惯而言，这种声明往往是发生了错误。因为我们可能原本是希望派生类覆盖基类的虚函数，但是不小心写错了。在 `C++11` 标准中，我们可以使用 `override` 关键字来说明派生类中的虚函数，这样可以让编译器帮我们一些错误。当我们在派生类中使用 `override` 标记了某个函数时，但没有覆盖已存在的虚函数，则编译器会报错。

```c++
class Base
{
  	public:
    	virtual void f1(int) const;
    	virtual void f2();
    	void f3();
};

class Derived : public Base
{
    public:
    	void f1(int) const override;	// 正确，派生类 f1 覆盖基类中的 f1 版本
    	void f2(int) override;	// 错误，Base 中没有形如 f2(int) 的虚函数。
    	void f3() override;		// 错误，f3 不是虚函数
    	void f4() override;		// Base 中没有 f4 函数
};

```

**只有虚函数才能被覆盖**。

### 3.2 final 关键字

`final` 在继承关系中，如果把某个类或类中的成员函数指定为 `final` ，则该类不能被继承，即不能作为基类；而指定的函数则在派生类不能被覆盖。

## 4. 纯虚函数

在一个虚函数的声明语句分号之前加 `=0` 可以将此虚函数声明为纯虚函数。 `=0` 只能出现在类内部的虚函数声明处。含有纯虚函数的类是抽象基类。
抽象基类不能定义对象，只负责定义接口。派生类中如果没有覆盖继承而来的纯虚函数，则它也是抽象类。