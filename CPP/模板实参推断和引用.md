
- [模板实参推断和引用](#模板实参推断和引用)
  - [1. 从左值引用函数参数推断类型](#1-从左值引用函数参数推断类型)
  - [2. 从右值引用函数参数推断类型](#2-从右值引用函数参数推断类型)
  - [3. 右值引用参数和引用折叠](#3-右值引用参数和引用折叠)
    - [3.1 第一个例外是右值引用参数的推断规则](#31-第一个例外是右值引用参数的推断规则)
    - [3.2 第二个例外是绑定规则---引用折叠](#32-第二个例外是绑定规则---引用折叠)

# 模板实参推断和引用

为了理解函数模板如何进行类型推断，考虑以下例子：

```cpp
template <typename T> void f(T &p);

```
函数参数 `p` 是一个模板类型参数 `T` 的引用，需要谨记两点：
1. 编译器会应用正常的引用绑定规则；
2. `const` 是底层的，不是顶层的。

## 1. 从左值引用函数参数推断类型

当一个函数参数是模板类型参数的一个普通引用时( 左值引用，即 `T&` )，绑定规则告诉我们，只能传递给它一个左值。如果实参是 `const` 的， 则 `T` 将被推断为 `const` 类型，如下示例：

```cpp
template <typename T> void f1( T& );    // 实参必须是一个左值

f1(i);  // i 是 int 变量，模板参数类型 T 是 int
f1(ci); // ci 是 const int 变量，模板参数类型 T 是 const int

f1(5);  // 错误，传递给 & 参数的实参必须是一个左值

```

而如果一个函数参数的类型是 `const T&`，则正常的绑定规则是可以传递给它任何类型的实参---一个对象(`const` 或 非 `const` )、一个临时对象或一个字面值常量。当实参本身是 `const` 时，`T` 的类型推断结果不会是一个 `const` 类型，因为 `const` 已经是函数参数类型的一部分。

```cpp

template <typename T> f2( const T& );   // 可以接收一个右值

f2(i);  // i 是 int 类型，T 是 int
f2(ci); // ci 是 const int，但 T 是 int
f2(5);  // 一个 const & 参数可以绑定一个右值，T 是 int
```

## 2. 从右值引用函数参数推断类型

当一个函数参数是一个右值引用时，正常的绑定规则是可以给它一个右值。类型推断过程类似于左值引用函数参数的推断过程，`T` 的类型推断是右值实参的类型。

```cpp

template <typename T> void f3( T && );

f3(5);  // 模板参数 T 的类型是 int
```

## 3. 右值引用参数和引用折叠

当 `i` 是一个 `int` 对象时，按正常的绑定规则是 `f3(i)` 这样的调用是不合法的。因为 `i` 是一个左值，不能将一个右值引用绑定到左值上。但是 `c++` 在正常的绑定规则以外，定义了两种例外规则，允许上面的绑定。这两种规则是标准库 `move` 正确实施的基础。

### 3.1 第一个例外是右值引用参数的推断规则

当把一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时 ( 如 `T&&` )，编译器推断模板类型参数为实参的左值引用类型。因此，当调用 `f3(i)` 时，编译器推断 `T` 的类型是 `int&`，而非 `int`。`T&` 被推断为 `int&` 似乎意味着 `f3` 的函数参数应该是一个类型 `int&` 的右值引用。通常，我们不能直接定义引用的引用。但通过 **类型别名** 或通过 **模板类型参数** 间接定义是可以的。
```cpp
	// 引用的引用：通过类型别名间接定义
    int x = 0;
    int y = 0;
    int z = 0;
    int a = 0;

    // typedef int& rf;
    using rf1 = int&;
    using rf2 = int&&;
    using rf3 = int&;
    using rf4 = int&&;
    
    rf1 &r1 = x;
    rf2 &r2 = y;
    rf3 &&r3 = z;
      
    rf4 &&r4 = a;   // cannot bind rvalue reference of type ‘rf4’ {aka ‘int&&’} to lvalue of type ‘int’

    r1 = 3;
    std::cout << x << " " << typeid(rf1).name() << "\n";

    r2 = 5;
    std::cout << y << " " << typeid(rf2).name() << "\n";
    
    r3 = 8;
    std::cout << z << " " << typeid(rf3).name() << "\n";

```

### 3.2 第二个例外是绑定规则---引用折叠

如果我们间接定义了引用的引用，则这些引用就形成了 "折叠"。在这种情况下，引用都折叠成一个普通的左值引用类型。新标准下，折叠规则扩展到右值引用，即只有出现右值引用的右值引用时，才折叠成右值引用。例如，对于给定类型 `X`:
1. `X& &、X& && 和 X&& &` 都折叠成类型 `X&`;
2. `X&& &&` 则折叠成类型 `X&&`。

**引用折叠只应用于间接创建的引用的引用，如类型别名或模板参数**。

综上，把上面规则 [1](#31-第一个例外是右值引用参数的推断规则) 和 [2](#32-第二个例外是绑定规则---引用折叠) 组合在一起，则表明我们可以对一个左值调用 `f3`。因此，当我们传递给 `f3` 的函数参数( `T&&` )时，编译器推断 `T` 为一个左值引用类型：
```cpp
f3(i);  // T 为 int&
f3(ci);     // T 为 const int&
```

`f3` 的函数参数时 `T&&` 且 `T` 推断为 `int&`，那么 `T&&` 是 `int& &&`，会折叠成 `int&`。因此，即使 `f3` 的函数参数形式是一个右值引用（`T&&`），此调用也会用一个左值引用类型（int&）实例化 `f3`：
`void f3<int&>(int&)`。