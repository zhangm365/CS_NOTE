
- [模板实参推断和引用](#模板实参推断和引用)
  - [1. 从左值引用函数参数推断类型](#1-从左值引用函数参数推断类型)
  - [2. 从右值引用函数参数推断类型](#2-从右值引用函数参数推断类型)
  - [3. 右值引用参数和引用折叠](#3-右值引用参数和引用折叠)
    - [3.1 第一个例外是右值引用参数的推断规则](#31-第一个例外是右值引用参数的推断规则)
    - [3.2 第二个例外是绑定规则---引用折叠](#32-第二个例外是绑定规则---引用折叠)
  - [4. 完美转发](#4-完美转发)
    - [4.1 `std::forward` 源码](#41-stdforward-源码)

# 模板实参推断和引用

为了理解函数模板如何进行类型推断，考虑以下例子：

```cpp
template <typename T> void f(T &p);

```
函数参数 `p` 是一个模板类型参数 `T` 的引用，需要谨记两点：
1. 编译器会应用正常的引用绑定规则；
2. `const` 是底层的，不是顶层的。

## 1. 从左值引用函数参数推断类型

当一个函数参数是模板类型参数的一个普通引用时( 左值引用，即 `T&` )，绑定规则告诉我们，只能传递给它一个左值。如果实参是 `const` 的， 则 `T` 将被推断为 `const` 类型，如下示例：

```cpp
template <typename T> void f1( T& );    // 实参必须是一个左值

f1(i);  // i 是 int 变量，模板参数类型 T 是 int
f1(ci); // ci 是 const int 变量，模板参数类型 T 是 const int

f1(5);  // 错误，传递给 & 参数的实参必须是一个左值

```

而如果一个函数参数的类型是 `const T&`，则正常的绑定规则是可以传递给它任何类型的实参：一个对象(`const` 或 非 `const` )、一个临时对象或一个字面值常量。当实参本身是 `const` 时，`T` 的类型推断结果不会是一个 `const` 类型，因为 `const` 已经是函数参数类型的一部分。

```cpp

template <typename T> f2( const T& );   // 可以接收一个右值

f2(i);    // i 是 int 类型，T 是 int
f2(ci);    // ci 是 const int，但 T 是 int
f2(5);    // 一个 const & 参数可以绑定一个右值，T 是 int
```

## 2. 从右值引用函数参数推断类型

当一个函数参数是一个右值引用时，正常的绑定规则是可以给它一个右值。类型推断过程类似于左值引用函数参数的推断过程，`T` 的类型推断是右值实参的类型。

```cpp

template <typename T> void f3( T && );

f3(5);  // 模板参数 T 的类型是 int
```

## 3. 右值引用参数和引用折叠

当 `i` 是一个 `int` 对象时，按正常的绑定规则是 `f3(i)` 这样的调用是不合法的。因为 `i` 是一个左值，不能将一个右值引用绑定到左值上。但是 `c++` 在正常的绑定规则以外，定义了两种例外规则，允许上面的绑定。这两种规则是标准库 `move` 正确实施的基础。

### 3.1 第一个例外是右值引用参数的推断规则

当把一个左值传递给函数的右值引用参数，且此右值引用指向 **模板类型参数** 时 ( 如 `T&&` )，编译器推断模板类型参数为实参的左值引用类型。因此，当调用 `f3(i)` 时，编译器推断 `T` 的类型是 `int&`，而非 `int`。

`T` 被推断为 `int&` 似乎意味着 `f3` 的函数参数应该是一个类型 `int&` 的右值引用。通常，我们不能直接定义引用的引用。但通过 **类型别名** 或通过 **模板类型参数** 间接定义是可以的。

```cpp
	// 引用的引用：通过类型别名间接定义
    int x = 0;
    int y = 0;
    int z = 0;
    int a = 0;

    // typedef int& rf;
    using rf1 = int&;
    using rf2 = int&&;
    
    rf1 &r1 = x;	// X& & 折叠成 X& （r1 的类型为 int&）
    rf1 &&r2 = y;    // X& && --> X& （r2 的类型为 int&）
    rf2 &r3 = z;    // X&& & --> X& （r3 的类型为 int&）
    rf2 &&r4 = a;   // X&& && --> X&& （r4 的类型为 int&&）cannot bind rvalue reference of type ‘rf2’ {aka ‘int&&’} to lvalue of type ‘int’

```

### 3.2 第二个例外是绑定规则---引用折叠

如果我们间接定义了引用的引用，则这些引用就形成了 "折叠"。在这种情况下，引用都折叠成一个普通的左值引用类型。新标准下，折叠规则扩展到右值引用，即只有出现右值引用的右值引用时，才折叠成右值引用。例如，对于给定类型 `X`:
1. `X& &、X& && 和 X&& &` 都折叠成类型 `X&`;
2. `X&& &&` 则折叠成类型 `X&&`。

**引用折叠只应用于间接创建的引用的引用，如类型别名或模板参数**。

综上，把上面规则 **[1](#31-第一个例外是右值引用参数的推断规则)** 和 **[2](#32-第二个例外是绑定规则---引用折叠) ** 组合在一起，则表明我们可以对一个左值调用 `f3`。因此，当我们传递给 `f3` 的函数参数( `T&&` )时，编译器推断 `T` 为一个左值引用类型：
```cpp
f3(i);  // T 为 int&
f3(ci);     // T 为 const int&
```

`f3` 的函数参数时 `T&&` 且 `T` 推断为 `int&`，那么 `T&&` 是 `int& &&`，会折叠成 `int&`。因此，即使 `f3` 的函数参数形式是一个右值引用（`T&&`），此调用也会用一个左值引用类型（int&）实例化 `f3`：
`void f3<int&>(int&)`。

这两个规则有以下两个重要结果：
1. 如果一个函数参数是一个**指向模板类型参数的右值引用**（如 `T&&`），则它可以被绑定到一个左值；
2. 如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通的左值引用参数（`T&`）。如果是一个右值，则推断出的模板实参类型是被引用的类型。

因此，形似函数模板 `f3` 的功能实现，它可以接受任意类型的参数，称为 **`万能引用`**。

## 4. 完美转发

标准库 `std::forward` 函数可以在函数调用过程中保持原始实参的类型信息。万能引用 + `std::forward` 的组合可以准确实现完美转发的功能。

### 4.1 `std::forward` 源码
```cpp
    
/**
*  @brief  Forward an lvalue.
*  @return The parameter cast to the specified type.
*
*  This function is used to implement "perfect forwarding".
*/
template<typename _Tp>
constexpr _Tp&&
forward(typename std::remove_reference<_Tp>::type& __t) noexcept
{ 
    return static_cast<_Tp&&>(__t); 
}

/**
*  @brief  Forward an rvalue.
*  @return The parameter cast to the specified type.
*
*  This function is used to implement "perfect forwarding".
*/
template<typename _Tp>
constexpr _Tp&&
forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
{
    static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
                   " substituting _Tp is an lvalue reference type");
    return static_cast<_Tp&&>(__t);
}
 
```

例如以下代码示例：

```cpp

#include <iostream>
#include <utility>

template <typename T>
void print( T &val )
{
    val = 3;
    printf("print(T&)\n");
}

template <typename T>
void print( T &&val )
{

    val = 6;
    printf("print(T&&)\n");

}



template <typename T>
void temTest( T &&v )
{

    print(v);   // 总是调用 print( T& )
    print(std::forward<T>(v));    // 完美转发
    print(std::move(v));    // 总是调用 print(T&&)

}

int main()
{

    int i = 0;
    temTest(i);
    std::cout << i << "\n";

    printf("===============\n");
    
    i = 0;
    temTest(std::move(i));
    std::cout << i << "\n";

    return 0;

}
```

## 5. 万能引用

符号 `&&` 可能是左值引用，也可能是右值引用，因此它称为万能引用（`universal reference`）。

### 5.1 万能引用的场合

如果一个变量或参数声明为 `T&&`，其中 **`T`** 是 **被推导的类型**，那么这个变量或参数就是一个万能引用。

对于一个引用，定义时必须初始化，因此，`universal reference` 的初始化决定了它是一个左值引用，还是一个右值引用：

- 如果用来初始化`universal reference`的表达式是一个左值，那么`universal reference`就变成`lvalue reference`。
- 如果用来初始化`universal reference`的表达式是一个右值，那么`universal reference`就变成`rvalue reference`。

```c++
template<typename T>
void f(T&& param); 

int a = 1;
f(a);    // 传入左值，那么 T&& 就是 lvalue reference, 即左值引用绑定了左值。T 的类型是 int& 
f(1);    // 传入右值，那么 T&& 就是 rvalue reference, 即右值引用绑定了右值。T 的类型是 int
```

