

[toc]

# 转换函数

## 一. 转换构造函数

## 1. 隐式的类类型转换

转换构造函数：如果一个类中含有只接受一个实参的构造函数，则它定义了转换为此类类型的隐式转换机制。因此，能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

```cpp
class Test
{
	public:
    	Test() = default;
    	Test( int val ) : i(val) {}
    	Test &combine( const Test & );
    private:
    	int i;
};

Test &Test::combine( const Test &rhs )
{
    this->i += rhs.i;
    return *this;
}

Test ite = 2;	// 隐式的类类型转换。转换构造函数, 拷贝初始化
// Test tmp(2);
// ite = tmp;  

Test ite2;
ite2.combine(2);	// 隐式的类类型转换


```



## 2. explicit 关键字作用：抑制构造函数定义的隐式转换

在存在隐式转换的程序上下文中，可以通过将构造函数声明为 **explicit** 加以阻止，而且 explicit 只对一个实参的构造函数有效。因此，explicit 构造函数只能用于直接初始化。

```cpp
class Test
{
	public:
    	Test() = default;
    	explicit Test( int val ) : i(val) {}	// 只能在类内声明构造函数时使用explicit关键字
    	Test &combine( const Test & );
    private:
    	int i;
};

Test &Test::combine( const Test &rhs )
{
    this->i += rhs.i;
    return *this;
}

//Test ite = 2;	// error: 加explicit抑制 隐式的类类型转换。转换构造函数, 拷贝初始化
 

Test ite2;
//ite2.combine(2);	// error : 

Test ite(2);	// explicit 构造函数只能用于直接初始化  
```



## 3. 标准库中含有显示构造函数的类

-   接受一个单参数的 const char * 的 string 构造函数不是 explicit 的；
-   接受一个容量参数的 vector 构造函数是 explicit 的。