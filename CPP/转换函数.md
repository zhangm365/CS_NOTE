- [转换函数](#转换函数)
	- [1. 转换构造函数](#1-转换构造函数)
		- [1.1 隐式的类类型转换](#11-隐式的类类型转换)
		- [1.2 explicit 关键字作用：抑制构造函数定义的隐式转换](#12-explicit-关键字作用抑制构造函数定义的隐式转换)
		- [1.3 标准库中含有显式构造函数的类](#13-标准库中含有显式构造函数的类)
		- [1.4 类型转换规则](#14-类型转换规则)



# 转换函数

转换函数通常可以分为两类，一类是将其他类型转为类类型，另一类是将类类型转为其他类型。

## 1. 转换构造函数

### 1.1 隐式的类类型转换

转换构造函数：如果一个类中含有只接受一个实参的构造函数，则它定义了转换为此类类型的隐式转换机制。因此，能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

```cpp
class Fraction
{
	public:
    	Fraction() = default;
    	Fraction( int num, int den = 1 ) : m_num(num), m_den(den) {}	// 将函数中的参数类型转为类类型
    	operator double() const		// 将类类型转为double型
        {
            return (double)(m_num / m_den);
        }
    
    	Fraction operator+( const Fraction & );
    private:
    	int m_num;	// 分子
    	int m_den;	// 分母
};

Fraction Fraction::operator+( const Fraction &rhs )
{
    return Fraction(((this->m_num) * (rhs.m_den) + (this->m_den) * (rhs.m_num)) / ((this->m_den) * (rhs.m_den)));
}

Fraction ite = 2;	// 隐式的类类型转换。转换构造函数, 拷贝初始化
// Fraction tmp(2, 1);
// ite = tmp;  


///---- 
Fraction f1(3,5);
double d = 4 + f1;	// 将 f1 转为 double 型，即调用 operator double() 将 f1 转为0.6

///----
Fraction f = f1 + 4;	// 调用 non-explicit 将 4 转化为 Fraction(4,1) 


```

### 1.2 explicit 关键字作用：抑制构造函数定义的隐式转换

在存在隐式转换的程序上下文中，可以通过将构造函数声明为 `explicit` 加以阻止，但 `explicit` 只对一个实参的构造函数有效。因此，`explicit` 构造函数只能用于直接初始化。

```cpp
class Test
{
	public:
    	Test() = default;
    	explicit Test( int val ) : i(val) {}	// 只能在类内声明构造函数时使用 explicit 关键字
    	Test &combine( const Test & );
    private:
    	int i;
};

Test &Test::combine( const Test &rhs )
{
    this->i += rhs.i;
    return *this;
}

//Test ite = 2;	// error: explicit 抑制隐式的类类型转换。转换构造函数, 拷贝初始化
 

Test ite2;
//ite2.combine(2);	// error : 

Test ite(2);	// explicit 构造函数只能用于直接初始化  
```



### 1.3 标准库中含有显式构造函数的类

- 接受一个单参数的 `const char *` 的 `string `构造函数不是 `explicit` 的；
- 接受一个容量参数的 `vector` 构造函数是 `explicit` 的。

### 1.4 类型转换规则

如果要为某个函数的所有参数（包括被 `this` 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是 `non-member`。

