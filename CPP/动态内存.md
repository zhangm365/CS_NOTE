



# 动态内存分配

动态内存分配是指在程序空间的堆上手动分配空间，从而来存储动态分配的对象。

## 1. `new `和 `delete `进行动态内存分配

`C++` 中，动态内存分配由一对运算符 **`new`** 和 **`delete`** 来完成。**`new`** 负责在动态内存中为对象分配空间并返回 一个指向该对象的指针。**`delete`** 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

动态内存的使用不当会出现内存泄漏或产生引用非法内存的指针。

动态内存分配存在三个常见问题：

1.  忘记 `delete` 内存，这会导致 "内存泄漏"；保证 `new` 和 `delete` 成对出现。
2.  使用已释放的对象；通常可以通过在释放内存后将指针置空，来检测这种错误。
3.  同一块内存释放两次。当两个指针指向同一动态对象，可能发生这种错误。

为了更安全地使用动态内存，新标准库提供了两种智能指针类型来管理动态对象。智能指针的行为类似常规指针，但重要的区别是它负责自动释放所指向的对象。

## 2. 智能指针：`shared_ptr，unique_ptr`

两种智能指针的区别在于管理底层指针的方式不同。

`shared_ptr` 是允许多个指针指向同一对象，`unique_ptr` 是 "独占" 所指向的对象。他们定义在 **`#include<memory>`** 头文件内。

### 2.1. `std::shared_ptr `类

智能指针是模板，因此，智能指针在创建时，必须提供指针可以指向的类型。通过 **`make_shared`** 函数创建一个 **`shared_ptr`** 可以指向的对象空间。

```c++
#include <memory>
// 定义智能指针, 默认初始化的智能指针中保存着一个空指针
shared_ptr<int> p;	// shared_ptr 可以指向 int 类型的对象
shared_ptr<string> ps;	// shared_ptr 可以指向 string 

p = make_shared<int>(5);	// p 指向一个值为 5 的 int 对象

```

#### (1). 语法要点

1.  不使用相同的内置指针初始化多个智能指针；因为初始化后的每个智能指针是独立的，它们的引用计数器没有共享，会导致动态内存多次释放。

    ```cpp
        auto pi = new int();
    
        shared_ptr<int> sp1(pi);
    
        // 不可用内置指针初始化多个智能指针, 如果这样做, 则会导致free(): double free detected in tcache 2
        shared_ptr<int> sp2(pi);
    ```

    

2.  不 delete 由方法 **get**() 返回的指针；因为可能导致多次释放同一块内存。

3.  不使用 **get**() 初始化一个智能指针；因为 **get** 方法返回的是一个原生指针，绑定新的智能指针后，新智能指针和原来的智能指针是相互独立的。

4.  如果使用了 **get**() 返回的指针，当最后一个对应的智能指针销毁后，此时这个指针就变为无效的了。

5.  如果使用智能指针管理的资源不是 **new** 分配的内存，记住传递给它一个删除器。（ p417 练习 14 & 15 ）

#### (2). 代码

```c++
template<typename T>
class Shared_Ptr
{
	public:
    	Shared_Ptr( T *PTR = nullptr ) : _PTR(PTR), _COUNT(new int(1)) {}
    	Shared_Ptr( const Shared_Ptr &rhs ) : _PTR(rhs._PTR), _COUNT(rhs._COUNT)
        {
            ++(*_COUNT);
        }
    
    	Shared_Ptr<T> &operator=( const Shared_Ptr &rhs )
        {
            if( this != &rhs )
            {
                if( (--(*_COUNT)) == 0 )	// 如果是最后一个指向的对象，则释放原来的内存空间
                {
                    delete _PTR;
                    delete _COUNT;
                }
                
                _PTR = rhs._PTR;
                _COUNT = rhs._COUNT;
                ++(*_COUNT);
            }
            
            return *this;
        }
    	
    	T &operator*()
        {
            return *_PTR;
        }
    	
    	T *operator->()
        {
            return _PTR;
        }
    	
    	~Shared_Ptr()
        {
            if( --(*_COUNT) == 0 )
            {
                delete _PTR;
                delete _COUNT;
                _PTR = nullptr;
                _COUNT = nullptr;
            }
        }
    
	private:
  		T *_PTR;	// 
    	int *_COUNT;	// 引用计数器
};
```



### 2.2 . `std::unique_ptr  `类

一个 `unique_ptr` 是小巧、高速的、具备 **只移型别** 的智能指针，对托管资源实现的是专属所有权语义。即某个时刻只能有一个 `unique_ptr `指向一个给定的对象。当 `unique_ptr `被销毁时，它所指向的对象也被销毁。

```c++
unique_ptr<double> p1;	// 可以指向一个 double 的 unique_ptr
unique_ptr<int> p2(new int(42));	// p2 指向一个值为 42 的 int

// 由于 unique_ptr 拥有它指向的对象，所以它不支持普通的拷贝或赋值操作。

unique_ptr<string> p1(new string("hello world"));
unique_ptr<string> p2(p1);	// error : unique_ptr 不支持拷贝
unique_ptr<string> p3;
p3 = p1;	// error ：unique_ptr 不支持赋值
```

#### (1). 要点

1. 默认地，析构资源采用 `delete` 运算符实现，但可以指定自定义删除器。

2. `unique_str` 可以转换成 `shared_ptr` 类型。

