

[toc]

# 动态内存分配

****

动态内存分配是指在程序空间的堆上手动分配空间，从而来存储动态分配的对象。

## 1. new 和 delete 进行动态内存分配

C++ 中，动态内存分配由一对运算符 **new** 和 **delete** 来完成。**new** 负责在动态内存中为对象分配空间并返回 一个指向该对象的指针。**delete** 接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

动态内存的使用不当会出现内存泄漏或产生引用非法内存的指针。

动态内存分配存在三个常见问题：

1.  忘记 delete 内存，这会导致 "内存泄漏"；保证 new 和 delete 成队出现。
2.  使用已释放的对象；通常可以通过在释放内存后将指针置空，来检测这种错误。
3.  同一块内存释放两次。当两个指针指向同一动态对象，可能发生这种错误。

为了更安全地使用动态内存，新标准库提供了两种智能指针类型来管理动态对象。智能指针的行为类似常规指针，但重要的区别是它负责自动释放所指向的对象。

## 2. 智能指针：shared_ptr，unique_ptr

两种智能指针的区别在于管理底层指针的方式不同。

shared_ptr 是允许多个指针指向同一对象，unique_ptr 是 "独占" 所指向的对象。他们定义在 **memory** 头文件内。

### (1) . shared_ptr 类

--------

智能指针是模板，因此，智能指针在创建时，必须提供指针可以指向的类型。通过 **make_shared** 函数创建一个 **shared_ptr** 可以指向的对象空间。

```c++
#include <memory>
// 定义智能指针, 默认初始化的智能指针中保存着一个空指针
shared_ptr<int> p;	// shared_ptr 可以指向 int 类型的对象
shared_ptr<string> ps;	// shared_ptr 可以指向 string 

p = make_shared<int>(5);	// p 指向一个值为 5 的 int 对象

```

#### notes

---

1.  不使用相同的内置指针初始化多个智能指针；因为初始化后的每个智能指针是独立的，它们的引用计数器没有共享，会导致动态内存多次释放。

    ```cpp
        auto pi = new int();
    
        shared_ptr<int> sp1(pi);
    
        // 不可用内置指针初始化多个智能指针, 如果这样做, 则会导致free(): double free detected in tcache 2
        shared_ptr<int> sp2(pi);
    ```

    

2.  不 delete 由方法 **get**() 返回的指针；因为可能导致多次释放同一块内存。

3.  不使用 **get**() 初始化一个智能指针；因为 **get** 方法返回的是一个原生指针，绑定新的智能指针后，新智能指针和原来的智能指针是相互独立的。

4.  如果使用了 **get**() 返回的指针，当最后一个对应的智能指针销毁后，此时这个指针就变为无效的了。

5.  如果使用智能指针管理的资源不是 **new** 分配的内存，记住传递给它一个删除器。（ p417 练习 14 & 15 ）

### (2) . unique_ptr  类

-------

一个 unique_ptr  "拥有" 它所指向的对象，即某个时刻只能有一个 unique_ptr 指向一个给定的对象。当 unique_ptr 被销毁时，它所指向的对象也被销毁。

```c++
unique_ptr<double> p1;	// 可以指向一个 double 的 unique_ptr
unique_ptr<int> p2(new int(42));	// p2 指向一个值为 42 的 int

// 由于 unique_ptr 拥有它指向的对象，所以它不支持普通的拷贝或赋值操作。

unique_ptr<string> p1(new string("hello world"));
unique_ptr<string> p2(p1);	// error : unique_ptr 不支持拷贝
unique_ptr<string> p3;
p3 = p1;	// error ：unique_ptr 不支持赋值
```

