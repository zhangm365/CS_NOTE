[toc]

# 基类&派生类

--------------------------

## 1. 基类

面向对象编程设计中，通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部是基类，其他类直接或间接从基类继承而来，这些继承而来的类称为派生类。

静态类型：变量或表达式的静态类型在编译时就已知的；
动态类型：变量或表达式表示的是内存中的对象的类型，在运行时解析得知。

## 2. 虚函数

基类将类型相关的函数声明为虚函数，即在函数的返回值前面冠以 `virtual` 关键字。虚函数可能在运行时才被解析，所以，所有虚函数必须要定义。
派生类中的函数，如果要覆盖从基类继承而来的虚函数，则它的形参类型必须与基类中的虚函数完全一致。
**动态绑定只有通过引用或指针调用虚函数时才会发生**。

## 3. 派生类

### 3.1 要点

1.  派生类对象可以访问基类的 `public` 、`protected` 访问控制符下的成员；

2.  因为派生类对象含有与基类对应的组成部分，所以派生类对象可以当成基类对象使用；

3.  基类的指针或引用可以绑定到派生类对象，即**派生类自动转换成基类对象的类型**；

4.  派生类必须使用**基类的构造函数**来初始化它的基类部分；

5.  在一个类名后面加关键字 `final` ，可以防止此类被其他类继承；

    ```cpp
    class NoDerived final {};	// NoDerived 不能被当做基类
    class Base {};
    class Last final : public Base {};	// 类 Last 不可以被继承
    class Bad : public NoDerived {};	// error : 类 NoDerived 不可以被继承
    class Bad2 : public Last {};	// error
    ```

6.  不能将基类转换成派生类。

7.  当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、赋值或移动，它的派生类部分会被忽略掉。

    ```cpp
    class Base {};
    class Derived : publid Base {};
    
    Derived d1;
    Base b1(d1);	// 使用 Base::Base( const Base & ) 构造函数
    b1 = d1;	// 调用 Base::operator=( const Base & ) 
    ```

8.  动态绑定只有当通过指针或引用调用虚函数才会发生；
9.  派生类中的虚函数要覆盖基类中的虚函数时，这两个虚函数的形参必须严格匹配；

## 4. final & override

### 4.1 override 关键字

当派生类定义一个函数和基类中虚函数的名字相同但形参列表不同，编译器会认为这是派生类中定义的一个新函数，与基类中原有的虚函数是独立的。因此，派生类的函数并没有覆盖掉基类中的版本，但就实际的编程习惯而言，这种声明往往是发生了错误。因为我们可能原本是希望派生类覆盖基类的虚函数，但是不小心写错了。在 `C++11` 标准中，我们可以使用 `override` 关键字来说明派生类中的虚函数，这样可以让编译器帮我们一些错误。当我们在派生类中使用 `override` 标记了某个函数时，但没有覆盖已存在的虚函数，则编译器会报错。

```c++
class Base
{
  	public:
    	virtual void f1(int) const;
    	virtual void f2();
    	void f3();
};

class Derived : public Base
{
    public:
    	void f1(int) const override;	// 正确，派生类 f1 覆盖基类中的 f1 版本
    	void f2(int) override;	// 错误，Base 中没有形如 f2(int) 的虚函数。
    	void f3() override;		// 错误，f3 不是虚函数
    	void f4() override;		// Base 中没有 f4 函数
};

```

综上，`override` 关键字用在**派生中的虚函数覆盖继承而来的虚函数**的场景。

### 4.2 final 关键字

`final` 在继承关系中，如果把某个类或类中的成员函数指定为 `final` ，则该类不能被继承，即不能作为基类；而指定的函数则在派生类不能被覆盖。



## 5. 纯虚函数

在一个虚函数的声明语句分号之前加 `=0` 可以将此虚函数声明为纯虚函数。 `=0` 只能出现在类内部的**虚函数声明**处。含有纯虚函数的类是抽象基类。
抽象基类不能定义对象，只负责定义接口。派生类中如果没有覆盖继承而来的纯虚函数，则它也是抽象类。

### 5.1 纯虚函数的作用

含有纯虚函数的类称为抽象类。抽象类是继承体系中进行**重构**的典型案例。代码示例：
`.\CPP_Primer_5e\ch15` 中的代码： `quote.h` 、`disc_quote.h` 、`bulk_quote_v2.h` 中对纯虚函数 `net_price` 的继承覆盖。

## 6. 继承中的类作用域

每个类定义自己的作用域，在这个作用域内定义类的成员。当存在继承关系时，派生类的作用域嵌套内在其基类中作用域之内。
因此，当一个变量名在派生类的作用域无法解析时，则编译器将继续在外层的基类作用域中寻找该名字的定义。

### 6.1 在编译时进行名字查找

一个对象、指针或引用的静态类型决定了该对象的哪些成员是可见的。即使静态类型和动态类型可能不一致，但我们能使用哪些成员仍然是由静态类型决定的。

### 6.2 函数调用的解析过程

理解函数调用的解析过程对理解 `C++` 的继承至关重要。假定我们调用 `p->mem()（或者 obj.mem()）` ，则依次执行以下四个步骤：

1.  首先确定 `p` （或 `obj` ）的静态类型。因为我们调用的是一个成员，所以该类型必须是类类型；
2.  在 `p`（或 `obj`）的静态类型对应的类中查找 `mem` ，如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错；
3.  一旦找到了 `mem`，就进行常规的类型检查以确保本次调用是否合法；
4.  如果合法，则编译器将根据调用的是否为虚函数而产生不同的代码：
    -   如果 `mem` 是虚函数且是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底是运行该虚函数的哪个版本，依据是对象的动态类型；
    -   反之，如果 `mem` 不是虚函数或我们是通过对象（非引用或指针）进行的调用，则编译器将产生一个常规函数调用。

### 6.3 名字查找先于类型检查

声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，派生类中的函数也不会重载其基类中的成员。
和其他作用域一样，如果派生类（内层作用域）的成员与基类（外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员仍被隐藏掉。

```cpp
struct Base
{
	int memfun();
};

struct Derived : public Base
{
	int memfun(int);	// 隐藏基类的 memfun
};

Derived d;
Base b;
b.memfun();	// 调用 Base::memfun
d.memfun(3);	// 调用 Derived::memfun
d.memfun();	// error, 参数列表为空的 memfun 被隐藏了
d.Base::memfun();	// 正确，调用 Base::memfun 
```

上述代码中，派生类中的成员函数 `memfun` 声明隐藏了基类中同名函数。调用语句 `d.memfun()` 是非法的，因为编译器在首先在 `Derived` 中找到了名为 `memfun`的成员，查找过程就会终止。但调用语句的 `memfun` 版本和类 `Derived` 中的同名版本不一致，编译器返回报错。

