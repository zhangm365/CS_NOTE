# ` Effective C++` 笔记

## 1. 类的专属 `static` 成员

```c++
// 头文件内
class GamePlayer{
private:
	static const int num;	// 类内的static常量声明式，即只声明了 num 变量，没有定义。
    
};

// 实现文件：static变量必须在实现文件内定义
const int GamePlayer::num = 3;	// num 变量的定义，定义时再设初值。


```

## 2. `const` 关键字

`const` 关键字可以指定一个语义约束：**一个不被改动的对象**，编译器会强制实施这项约束。`const` 可以修饰多种对象。

### 2.1 `const` 修饰指针

`const` 在 `*` 左边表示被指物是常量，在 `*` 右边表示指针自身是常量，如果出现在 `*` 两边，表示被指物和指针两者都是常量。

```c++
char str[] = "hello world"
// non-const pointer, const data
const char *p = str;
// const pointer, non-const data
char* const p = str;
// const pointer, const data
const char* const p = str;
```

### 2.2 `const` 修饰迭代器

`STL` 迭代器系以指针为根据塑造出来的，所以迭代器的作用像 `T*` 指针。声明迭代器为 `const` 就像指针为 `const` 一样（即声明一个 `T* const`指针）。

```c++
std::vector<int> vec;

const std::vector<int>::iterator iter = vec.begin();	// iter 作用像个 T* const
++iter;		// 错误
*iter = 10;	// 改变 iter 所指物

std::vector<int>::const_iterator cIter = vec.begin();	// cIter 作用像 const T*
++cIter;	// 
*cIter = 10;	// 错误；
```

### 2.3 `const` 成员函数

`const` 成员函数主要有两个作用：

1. 使得 `class` 接口容易理解，因为可以得知哪些函数可以改动对象内容，哪些不行；
2. 使 "操作 `const` 对象" 成为可能。

如果两个成员函数只是常量性不同，可以被重载。`const` 成员函数保证不修改类内的成员，而 `non-const` 成员函数可以对其对象进行修改。如以下示例：

```c++
class TextBlock{
public:
    
    const char& operator[]( std::size_t pos ) const // operator[] for const 对象
    {
        return text[pos];
    }
    
    char& operator[]( std::size_t pos )	// operator[] for non-const 对象
    {
        return text[pos];
    }
    
private:
	std::string text;
};


// 使用方法
TextBlock tb("hello");
cout << tb[0];	// call non-const TextBlock::operator[]

const TextBlock ctb("world");
cout << ctb[0];	// call const TextBlock::operator[]




```

当 `const`和`non-const`成员函数有着实质等价的实现时，令`non-const`版本调用`const`版本可避免代码，如下：

```c++
class TextBlock{
    public:
    	const char& operator[](std::size_t pos) const
        {
            ...
            return text[pos];
        }
    
    	char& operator[](std::size_t pos)
        {
            return const_cast<char&>(	// 将 op[] 的返回值 const 转除
                static_cast<const TextBlock&>(*this)	// 为 *this 加上 const 
                	[pos] 							// 调用 const op[]
            );
        }
    
    private:
    	string text;
}
```

`non-const operator[]` 调用其 `const` 兄弟，进行了两次类型转换：

1. 将 `*this` 的原始类型 `TextBlock&` 转换成 `const TextBlock&`（通过 `static_cast` 实现），使得其可以调用 `const operator[]`；
2. 从`const operator[]` 的返回值中移除 `const`（通过 `const_cast` 实现）；

