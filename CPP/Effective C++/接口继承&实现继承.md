# 接口继承与实现继承

在实现 `public` 继承后，会有两个函数继承形式：函数接口继承与函数实现继承。

类中的成员函数分为三类： `pure virtual`函数、`impure virtual`函数和 `non-virtual` 函数。如以下继承体系：

```c++
class Shape {    // 抽象类
public:    
    virtual void draw() const = 0;    // pure virtual    
    virtual void error(const std::string& msg);    // impure virtual
    int objectID( ) const;    // non-virtual 
	...
};

class Rectangle: public Shape { ... };
class Ellipse: public Shape { ... };
```



## 1. `pure virtual` 函数

函数 `draw` 是纯虚函数，在基类中没有定义。含有纯虚函数的类为抽象类，不能实例化对象。

因此，声明为纯虚函数的目的就是让派生类只继承其接口。

## 2. `impure virtual` 函数

声明为 `impure virtual` 函数的目的是让派生类继承该函数的接口与缺省实现。

同时不要重新定义一个继承而来的缺省参数值，因为缺省参数值是静态绑定，而 `virtual` 函数是动态绑定的。

```cpp
class Shape {	// 条款 37
public:    
	enum ShapeColor { Red, Green, Blue };    
	void draw(ShapeColor color = Red) const     //如今它是non-virtual    
	{        
		doDraw(color);                        //调用一个virtual    
	}    
    ...
	private:
    	virtual void doDraw(ShapeColor color) const = 0;	//真正的工作在此处完成
};                                                


class Rectangle: public Shape {
public:    
    ...
private:    
    virtual void doDraw(ShapeColor color) const;     //注意，不须指定缺省参数值。
};
```



## 3. `non-virtual` 函数

声明为 `non-virtual` 函数的目的是令派生类继承函数的接口及一份强制性实现。`non-virtual`函数代表的意义是 **不变性** 凌驾 **特异性**。

在派生类中绝不重新定义继承来的 `non-virtual` 成员函数。

