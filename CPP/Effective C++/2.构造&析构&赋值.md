# ` Effective C++` 笔记

## 1. 多态基类声明为 `virtual` 析构函数

任何类只要带有 `virtual` 函数都应该含有一个 `virtual` 析构函数。

## 2. `operator=` 返回 `reference to *this`

为了实现 **连锁赋值**，赋值运算符必须返回一个 `reference` 指向操作符的左侧实参。

```cpp
class Widget{
public:
    Widget& operator=( const Widget &rhs )	// 返回类型是个 reference, 指向当前对象。
    {
        ...
            return *this;	// 返回左侧对象
    }
};
```

## 3. `operator=` 中处理自我赋值情况

一份不安全的 `operator=` 实现版本：

```c++
class Bitmap {};

class Widget {
    ...
private:
    Bitmap *pb;	// 指向动态内存分配的对象
};

Widget& Widget::operator=( const Widget &rhs )
{
    delete pb;	// 删除当前对象指向的 pb 空间
    pb = new Bitmap(*rhs.pb);	// 指向 rhs.pb 的副本
    return *this;
}

```

这里自我赋值的问题是，`operator=` 函数内的 `*this` 和 `rhs` 可能指向同一个对象。如果成立的话，则 `delete` 不仅删除当前对象的 `Bitmap`，也会删除 `rhs` 的 `Bitmap`，那么在函数末尾，`Widget` 将持有一个指针指向一个已被删除的对象。

为了防止这种错误，`operator=` 不仅要考虑 "自我赋值安全性"，也要考虑 "异常安全性"。如果 `new Bitmap` 导致异常，`Widget` 也将最终持有一个指针指向一块被删除的 `Bitmap`。

因此，可以导出以下异常安全（及自我赋值安全）的代码：

```c++
Widget& Widget::operator=( const Widget &rhs )
{
	Bitmap *pt = pb;
	pb = new Bitmap(*rhs.pb);	// 
    delete pt;	// 删除原来的 pb 空间
    
    return *this;
}
```

更进一步，考虑 `copy and swap` 技术，来实现一个更好地 `operator=` 版本：

```cpp
class Widget{
...
	void swap( Widget &rhs )	// 交换 *this 和 rhs 的数据
	{
	...
	}
};

Widget& Widget::operator=( const Widget &rhs )
{
	Widget tmp(rhs);
    swap(tmp);
    
    return *this;
}

```

