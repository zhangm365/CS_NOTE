# 对象的移动

- [对象的移动](#对象的移动)
  - [1. 右值引用](#1-右值引用)
  - [2. 移动构造函数](#2-移动构造函数)
  - [3. `std::move` 语义](#3-stdmove-语义)
    - [3.1 `std::move` 的定义](#31-stdmove-的定义)
    - [3.2 `std::move` 工作原理](#32-stdmove-工作原理)

## 1. 右值引用

新标准的一个最主要的特性是支持对象的移动而非拷贝对象的能力。在某些情况下，移动而非拷贝对象会大幅度提升性能。
标准库容器、`string`、`shared_ptr` 类既支持移动也支持拷贝，而 `IO` 类和 `unique_ptr` 类可以移动但不能拷贝。

为了支持移动操作，新标准引入了一种新的引用类型---**右值引用**。所谓右值引用就是必须绑定到右值的引用，通过 `&&` 来获得右值引用。
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的地址）。

返回左值引用的函数、赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。因此，可以将左值引用绑定到此类表达式的结果上。
返回非引用的函数、算术、关系、位以及后置递增/递减运算符，都生成右值。

因此，左值具有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。右值引用指向将要被销毁的对象。

## 2. 移动构造函数

为了支持移动操作，我们要定义 **移动构造函数** 和 **移动赋值运算符**。这两个成员类似对应的拷贝操作，但它们是从给定的对象中 "窃取" 资源而不是拷贝资源。

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不用于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。同时，与拷贝构造函数一样，任何额外的参数都必须有默认实参。移动构造函数将数据从其参数移动到新创建的对象中，

## 3. `std::move` 语义

标准库 `std::move` 函数是一个使用右值引用的函数模板，某种程度上它是编译器考虑表达式值的方式之间的转换器。

### 3.1 `std::move` 的定义

`std::move` 用来标识对象 `t` 可被移动，即允许有效地将资源从 `t` 转移到另一个对象。它将产生一个标识参数 `t` 的 `xvalue expression`。如下是标准库中 `std::move` 的源码：

```cpp
// Defined in header <utility>
// (since C++11) --> (until C++14)
template<class T>
typename std::remove_reference<T>::type&& move(T&& t) noexcept;

// (since C++14)
template<class T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept;

// 通过 static_cast 将参数转换为右值引用
template<class T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(t);
}

```

`std::move` 实际上不会移动任何东西，它只是将一个参数强制转换为右值引用。


我们不能直接将一个右值引用绑定到一个左值上，但是可以使用 `move` 函数获得一个绑定到左值上的右值引用类型。

```cpp

int i = 0;
int &r = i;

int &&rr = r;  // error, 不能将右值引用绑定到左值上。

int &&rr = std::move(r);    // ok

```

`move` 函数参数 `T&&` 是一个指向模板类型参数的右值引用，通过引用折叠，此参数可以与任何类型的实参匹配。特别地，我们既可以传递给 `move` 一个左值，也可以传递给它一个右值。

```cpp
string s1("hello"), s2;

s2 = std::move(string("world"));    // ok, 从一个右值移动数据
s2 = std::move(s1);     // ok, 但赋值之后，s1 的值是不确定的

```

### 3.2 `std::move` 工作原理

在 `s2` 的第一个赋值中，传给 `move` 的实参是 `string` 的构造函数的右值结果，因此，在 `std::move(string("world"))` 中：

1. `T` 被推断为 `string`；
2. `remove_reference` 用 `string` 实例化；
3. `remove_reference<string>` 的 `type` 是 `string`；
4. `move` 的返回类型是 `string&&`；
5. `move` 的参数 `t` 类型是 `string&&`。

因此，上面的调用就实例化为以下形式：

```cpp
string&& move(string &&t) {
    return static_cast<string&&>(t);    // t 的类型已经是 string&&，类型转换什么都不做了。
}
```

而在第二个赋值中，`move` 的实参是左值类型，因此，在 `std::move(s1)` 中：

1. `T` 被推断为 `string&`；
2. `remove_reference` 用 `string&` 实例化；
3. `remove_reference<string>` 的 `type` 是 `string`；
4. `move` 的返回类型是 `string&&`；
5. `move` 的参数 `t` 类型引用折叠 `& &&` 为 `string&`。

这个调用实例化为：

```cpp
string&& move(string &t) {
    return static_cast<string&&>(t);    // 一个左值通过 static_cast 到一个右值引用是允许的
}
```
