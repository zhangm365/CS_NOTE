- [对象的移动](#对象的移动)
  - [1. 右值引用](#1-右值引用)
  - [2. 移动构造函数](#2-移动构造函数)
  - [3. `std::move` 语义](#3-stdmove-语义)

# 对象的移动

## 1. 右值引用

新标准的一个最主要的特性是支持对象的移动而非拷贝对象的能力。在某些情况下，移动而非拷贝对象会大幅度提升性能。
标准库容器、`string`、`shared_ptr` 类既支持移动也支持拷贝，而 `IO` 类和 `unique_ptr` 类可以移动但不能拷贝。

为了支持移动操作，新标准引入了一种新的引用类型---**右值引用**。所谓右值引用就是必须绑定到右值的引用，通过 `&&` 来获得右值引用。
当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的地址）。

返回左值引用的函数、赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。因此，可以将左值引用绑定到此类表达式的结果上。
返回非引用的函数、算术、关系、位以及后置递增/递减运算符，都生成右值。

因此，左值具有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。右值引用指向将要被销毁的对象。

## 2. 移动构造函数

为了支持移动操作，我们要定义 **移动构造函数** 和 **移动赋值运算符**。这两个成员类似对应的拷贝操作，但它们是从给定的对象中 "窃取" 资源而不是拷贝资源。

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不用于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。同时，与拷贝构造函数一样，任何额外的参数都必须有默认实参。移动构造函数将数据从其参数移动到新创建的对象中，

## 3. `std::move` 语义

标准库 `move` 函数是一个使用右值引用的函数模板。
我们不能直接将一个右值引用绑定到一个左值上，但是可以使用 `move` 函数获得一个绑定到左值上的右值引用类型。

```cpp

int i = 0;
int &r = i;

int &&rr = r;  // error, 不能将右值引用绑定到左值上。

int &&rr = std::move(r);    // ok

```
如下是标准库中 `move` 的定义：

```cpp
template<typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}

```

`move` 函数参数 `T&&` 是一个指向模板类型参数的右值引用，通过引用折叠，此参数可以与任何类型的实参匹配。特别地，我们既可以传递给 `move` 一个左值，也可以传递给它一个右值。

```cpp
string s1("hello"), s2;

s2 = std::move(string("wordl"));    // ok, 从一个右值移动数据
s2 = std::move(s1);     // ok, 但赋值之后，s1 的值是不确定的

```


