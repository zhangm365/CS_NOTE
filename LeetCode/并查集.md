# 并查集（`Union-Find`）

并查集算法主要解决图论中的「动态连通性」。

我们使用森林（若干颗树）来表示图的连通性，用数组具体实现这个森林。即 **问题的模型用森林表示，具体的数据结构是数组**。

```c++
class UF
{
    public:
    	UF(int n = 0)
        {
            count = n;    // 初始连通分量是 n，即 n 个独立的节点
            parent.resize(n);
            size.resize(n);
            for( int i = 0; i < n; ++i )
            {
                parent[i] = i;    // 每个节点 i 初始指向自身
                size[i] = 1;
            }
        }
    	
    	// 连通两个节点
        void union_two(int p, int q)    
        {
            int rootP = find(p);
            int rootQ = find(q);

            if( rootQ == rootP ) return;

            if( size[rootQ] > size[rootP] )    // 小树接到大树上，保证树的平衡性
            {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];

            }
            else
            {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            }

            count--;    // 连通分量减1

        }

		// 查找某个节点的父节点
        int find(int x)    
        {

            while( parent[x] != x )
            {
                parent[x] = parent[parent[x]];
                x = parent[x];
            }

            return x;
        }
		
    	// 判断两个节点是否连通
        bool connected(int p, int q)
        {

            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;

        }
    
    private:
    	int count;    // 连通分量
    	vector<int> parent;    // 数组表示一棵树。用来保存节点的根节点
    	vector<int> size;    // 每颗树中包含的节点
};
```

