[toc]

# 动态规划解题技巧

## 一. 解题思路



### 1. 动态规划的三个要素 

-   动态规划一般形式就是求最值问题。求解动态规划的核心问题是穷举。所以，用动态规划思想求最值问题，就是穷举出所有可行的解，然后求其中的最值。

    但是动态规划的穷举问题有些特殊，这类穷举问题存在「**重叠子问题**」，所以需要「备忘录」或「DP table」来优化穷举过程，避免不必要的计算。

-   动态规划问题一定具备「**最优子结构**」，这样通过子问题的最优解得到原问题的最值。
-   动态规划只有列举出正确的「**状态转移方程**」，才能正确的穷举。



### 2. 动态规划框架

首先明确状态转移方程如何定义。

思路：明确base case ---> 明确 「状态」---> 明确「选择」---> 定义dp数组/函数的含义。

```c++
# 初始化 base case
dp[0][0][...] = base;
# 状态转移
for 状态1 in 所有状态:
	for 状态2 in 所有状态：
        for ......
			dp[状态1][状态2][...] = 求最值(选择1, 选择2, ...)
```



### 3.  动态规划是「自底向上 」求解过程，递归是 「自顶向下 」

斐波那契数列的求解案例：

-   直接递归解法

    ```c++
    int fib( int n )
    {
        if( n == 1 || n == 2 ) return 1;
        return fib(n-1) + fib(n-2);
    }
    ```

    此题求解过程中存在重复子问题，所以在递归过程中，存在大量的重复计算。时间复杂度是指数级的，为 O( $2^n$ )。

-   含有备忘录的递归解法

    ```c++
    int fib( int n )
    {
    	if( n <= 0 ) return 0;
    	std::vector<int> demo(n+1, 0);
    	return helper( demo, n );
    }
    
    int helper( vector<int>&demo, int n )
    {
        // base case
    	if( n == 1 || n == 2 ) return 1;
    	if( demo[n] != 0 ) return demo[n];	// 备忘录已存, 则立即返回
    	demo[n] = helper( demo, n-1 ) + helper( demo, n-2 );
    	return demo[n];
    }
    ```



-   动态规划

    此题的状态转移方程为
    $$
    f(n) = \left\{
    \begin{aligned}
    & 1, \quad n = 1, 2 \\
    & f(n-1) + f(n-2), \quad n > 2
    \end{aligned}
    \right.
    $$
    

    ```cpp
    int fib( int n )
    {
        if( n == 1 || n == 2 ) return 1;
        vector<int> dp(n, 0);
        // base case 
        dp[0] = dp[1] = 2;
        for( int i = 2; i < n; ++i )
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
        
    }
    ```

    