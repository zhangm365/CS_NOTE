

[toc]

# leetcode : https://leetcode-cn.com/problems/target-sum/



## 采用动态规划求解，转化为背包问题。

### 1. 分析问题    

​	给定一个原集合 nums。
​    把它分成两个子集: 用于 + 号操作的集合 A，用于 - 号操作的集合B。sum() 表示求和操作，则可以得到以下表达式： 

​	sum(A) - sum(B) = target;

​	sum(A) = target + sum(B);

​	2*sum(A) = target + sum(nums) ;

​	sum(A) = (target + sum(nums)) / 2;

​	故问题转为 nums 中 有多少个 子集 A，使得集合 A 中所有元素之和为 (target + sum(nums)) / 2。

​	因此，这个问题就变成了 背包问题：

​	**有一个背包，容量为** **`sum`**，现在给你 **`N`** **个物品，第** **`i`** **个物品的重量为** **`nums[i - 1]`**（**`1 <= i <= N`**），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包？

### 2. 动态规划法

1.  确定「状态」和「选择」。

    状态 ： **背包的容量**和**可选择的商品**。

    选择 ： 装进背包 或 不装进背包。

2.  dp 数组的定义

    **`dp[i][j]`**：表示只在前 `i` 个物品中选择，若当前背包容量为 `j` ，则最多可以有多少种方法恰好装满背包？

    即在我们求解的问题中含义就是：若只在 `nums` 的前 `i` 个元素中选择，目标和为 `j` ，则最多有多少种划分子集的方法？ 

3.  状态转移

    根据上面的「状态」，对 **`dp[i][j]`** 可得到以下状态转移：

    如果不把 **`nums[i]`** 放入目标子集中，即表示第 **`i+1`** 个物品不放入背包中，则此时的方法数取决于上一个状态 **`dp[i-1][j]`** 的方法数；

    如果把 **`nums[i]`** 放入目标子集中，即表示第 **`i+1`** 个物品放入背包中，则此时的方法数取决于前 **`i`** 个物品有几种方法可以装满 `j-nums[i-1]` 的重量，所以取决于 **`dp[i-1][j-nums[i-1]]`** 的方法数；

    **`dp[i][j]`** 是装满背包的总方法数，所以应该是以上两种结果的求和，得到以下状态转移方程：

    `dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]`



```c++
class Solution {
public:
 
    int findTargetSumWays(vector<int>& nums, int target) {
        
        if( nums.size() == 0 ) return 0;
        
        int sum = 0;
        for( int val : nums ) sum += val;
        // 两种分法不合理
        if( sum < target || (sum + target) % 2 == 1 ) return 0;
     
        return subsets( nums, (sum + target) / 2 );
        
        
    }
    
    int subsets( vector<int>& nums, int sum )
    {
        
        int n = nums.size();
        
        // dp[i][j] : 前 i 个物品, 背包容量 为 j 时， 则由多少种装法？
        vector<vector<int>> dp( n+1, vector<int>(sum+1, 0));
        
        // base case：全部不装，也是一种装法
        for( int i = 0; i <= n; ++i )
        {
            dp[i][0] = 1;
        }
        
        
        for( int i = 1; i <= n; ++i )
        {
            for( int j = 1; j <= sum; ++j )
            {
                if( j >= nums[i-1] ) 
                {
				   // 两种选择的结果之和
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
                }
                else    // 背包空间不足
                {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        
        
        return dp[n][sum];
        
    }
    
};
```

