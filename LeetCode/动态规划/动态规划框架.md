[toc]

# 动态规划解题技巧

## 一. 解题思路



### 1. 动态规划的三个要素 

-   动态规划一般形式就是求最值问题。求解动态规划的核心问题是穷举。所以，用动态规划思想求最值问题，就是穷举出所有可行的解，然后求其中的最值。

    但是动态规划的穷举问题有些特殊，这类穷举问题存在「**重叠子问题**」，所以需要「备忘录」或「DP table」来优化穷举过程，避免不必要的计算。

-   动态规划问题一定具备「**最优子结构**」，这样通过子问题的最优解得到原问题的最值。
-   动态规划只有列举出正确的「**状态转移方程**」，才能正确的穷举。



### 2. 动态规划框架

首先明确状态转移方程如何定义。

思路：明确base case ---> 明确 「状态」---> 明确「选择」---> 定义dp数组/函数的含义。

```c++
# 初始化 base case
dp[0][0][...] = base;
# 状态转移
for 状态1 in 所有状态:
	for 状态2 in 所有状态：
        for ......
			dp[状态1][状态2][...] = 求最值(选择1, 选择2, ...)
```



### 3 . 如何找到动态规划的状态转移关系？

动态规划中的状态转移方程是最难的一环。当找到原问题的状态转移关系后，则该问题最终就被解决了。

**动态规划的核心思想是数学归纳法** 。动态规划的状态转移关系总结如下：

1.  首先必须明确 dp 数组的定义。只有准确定义 dp 数组所存数据的含义，才能进行后续的求解过程；
2.  根据已定义好的 dp 数组，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，意味着找出了问题求解的规律，则状态转移方程即可得到。

上述两个步骤是循序渐进的，如果第二步无法完成，则可能是因为第一步中 dp 数组的定义不恰当，需要重新定义；或者 dp 数组中存储的信息不够，无法推出下一步的答案，那么，可以尝试扩大 dp 数组的定义维度，如扩成 二维数组甚至三维数组。



### 4 .  动态规划是「自底向上 」求解过程，递归是 「自顶向下 」

斐波那契数列的求解案例：

-   直接递归解法

    ```c++
    int fib( int n )
    {
        if( n == 1 || n == 2 ) return 1;
        return fib(n-1) + fib(n-2);
    }
    ```

    此题求解过程中存在重复子问题，所以在递归过程中，存在大量的重复计算。时间复杂度是指数级的，为 O( $2^n$ )。

-   含有备忘录的递归解法

    ```c++
    int fib( int n )
    {
    	if( n <= 0 ) return 0;
    	std::vector<int> demo(n+1, 0);
    	return helper( demo, n );
    }
    
    int helper( vector<int>&demo, int n )
    {
        // base case
    	if( n == 1 || n == 2 ) return 1;
    	if( demo[n] != 0 ) return demo[n];	// 备忘录已存, 则立即返回
    	demo[n] = helper( demo, n-1 ) + helper( demo, n-2 );
    	return demo[n];
    }
    ```



-   动态规划

    此题的状态转移方程为
    $$
    f(n) = \left\{
    \begin{aligned}
    & 1, \quad n = 1, 2 \\
    & f(n-1) + f(n-2), \quad n > 2
    \end{aligned}
    \right.
    $$
    

    ```cpp
    int fib( int n )
    {
        if( n == 1 || n == 2 ) return 1;
        vector<int> dp(n, 0);
        // base case 
        dp[0] = dp[1] = 2;
        for( int i = 2; i < n; ++i )
        {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n-1];
        
    }
    ```

    