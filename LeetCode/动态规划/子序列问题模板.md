[toc]

# 子序列问题模板



## 1. 求解思路

子序列问题是一类很常见且典型的算法问题。子序列相对于子串、子数组要难点。因为前者是可以不连续的序列，而后者必须是连续子集。

子序列问题很可能涉及两个字符串，比如求解 **最长公共子序列** 问题 (LC1143) 。

子序列问题通常是 **子序列和最值** 的组合，所以几乎可以肯定是 **动态规划** 求解思路，时间复杂度为  $ O(N^2) $ 。

既然要用到动态规划，就必须准确定义 dp 数组，找出状态转移方程。根据 dp 数组的定义思路，可以对子序列问题的求解总结两种思路模板。

不同的问题运用不同的模板思路求解。



### 1.  第一种思路：一维的 dp 数组

```c++
int n = nums.size();

vector<int> dp(n, 0);

for( int i = 0 ; i < n; ++i )
{
    for( int j = 0; j < i; ++j )
    {
        dp[i] = 最值(dp[i], dp[j]...);
    }
}
```

**最长递增子序列** (LC300) 就是使用上面的模板。在这个思路中 dp 数组的定义是：

`在子数组 nums[0...i] 中，以 nums[i] 为结尾的目标子序列的长度是 dp[i] `。

这样可以使用归纳法，容易地找到状态转移方程。



### 2.  第二种思路：二维的 dp 数组

```c++
int m = s1.size();
int n = s2.size();

vector<vector<int>> dp(m+1, vector<int>(n+1, 0));

for( int i = 1 ; i <= m; ++i )
{
    for( int j = 1; j <= n; ++j )
    {
        if( s1[i-1] == s[j-1] )
        	dp[i][j] = dp[i-1][j-1]+...;
       	else
            dp[i][j] = 最值(dp[...][...], dp[...][...]);
    }
}
```

子序列问题，这种思路较常见。尤其是涉及两个字符串/数组的子序列问题。

在这个思路中，二维 dp 数组的定义又可以分为「只涉及一个字符串」和 「两个字符串」两种情况。

1.  涉及一个字符串时（最长回文子序列）， dp 数组的定义如下：

    `在子数组中 nums[i...j] 中，我们要求的子序列长度为 dp[i][j]` 。

2.  涉及两个字符串时，dp 数组的定义如下：

    `在子数组 s1[0...i] 和 s2[0...j] 中，我们要求的子序列长度为dp[i][j]`。 

    例如最长公共子序列、编辑距离等都是采用这种思路求解。