

# 最长回文子串

题目链接: https://leetcode-cn.com/problems/longest-palindromic-substring/

## 1.  暴力法。时间复杂度O(N^3).  此解法会超时。

```c++
class Solution {
public:
    string longestPalindrome(string s) {

        if( s.empty() ) return "";
        
        int len = 1;	//默认长度
        int start = 0;	// 记录子串的起始位置
        
        for( int i = 0; i < s.size(); i++ )
        {

            bool flag = false;
            for( int j = s.size()-1; j > i; j-- )
            {
                               
                flag = isPalicString(s, i, j);
                if(flag)
                {
                    if( j-i+1 > len)
                    {
                        len = j-i+1;
                        start = i;
                    }  
                }

            }
            
        }
        
        //printf("start = %d, len = %d\n", start, len);
        return s.substr(start, len);

    }


    // 判断某个字符串是否为回文串
    bool isPalicString( string str, int start, int end )
    {
        if( str.empty() || start >= end ) return true;
        int i = start, j = end;

        while( i < j )
        {
            if( str[i] != str[j] ) return false;
            i++;
            j--;
        }

        return true;

    }
};
```

## 2. 中心扩散法：从中间扩展字符串长度来判断是否为回文串。时间复杂度O(n^2)，空间O(1)

```c++
class Solution {
public:
    string longestPalindrome(string s) {

        if( s.size() < 2 ) return s;
        
        // 结果串
        string res = "";


        for( int i = 0; i < s.size(); i++ )
        {
			
            string s1 = extendFromMid(i, i);	// extend odd length
            string s2 =extendFromMid(i, i+1);	// extend even length
			
            // 将较大长度的回文串赋值给res
            if( s1.size() > res.size() ) res = s1;
            if( s2.size() > res.size() ) res = s2;
            
        }
        
        return res;

    }


    // 从中间扩展字符串来判断是否为回文串
    string extendFromMid( string& str, int i, int j )
    {
        // i向左扩展, j向右扩展
        while( i >= 0 && j < str.size() )
        {
            if( str[i] != str[j] ) break;
            i--;
            j++;
        }
       	
        // 此时字符串长度为j-i-2+1
        return str.substr(i+1, j-i-2+1);

    }
};
```

